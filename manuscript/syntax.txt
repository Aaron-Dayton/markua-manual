{mainmatter}

# Markua Syntax

Markua syntax is heavily based on Markdown syntax, and is adapted for the needs of books and documents.

Markua manuscripts can be used to produce every current popular type of ebook format: PDF, EPUB, MOBI and HTML. The computer programs which do this transformation are called Markua Processors. These programs understand both Markua syntax and how to generate the various output formats.

The Markua specification defines a precise mapping from Markua to HTML and to book and document concepts. While HTML is just one of the output formats of Markua, it is also the basis of EPUB. So, the mapping to HTML is fully specified and the mapping to EPUB is mostly specified. The mapping to PDF, MOBI and other formats is not discussed, and neither are the choices for the CSS to accompany the HTML produced by Markua--all of these are implementation-dependent, in order to encourage creativity and competition in the Markua ecosystem.

This chapter is an informal specification of all of Markua's syntax. In this chapter, the HTML that is generated is only briefly mentioned where it's interesting. To learn the exact mapping to HTML, and for a more formal specification, read the remaining chapters.

## Text Formatting

Markua's goal is to provide all the semantic formatting required by authors. Formatting that could be done by a book designer without needing to discuss it with the author is considered orthogonal to Markua, and is largely omitted from Markua.

Markua is a plain text format designed for the writing of books and documents. Books and documents have various types of text formatting in them: bold, italic, underline, strikethrough, superscript and subscript.

Here's how to do basic, semantic text formatting.

Italic
: To produce *italic text*, surround it with either `_one underscore_` (producing `<i>` in HTML) or `*one asterisk*` (producing `<em>` in HTML[^w3c_em]).

Bold
: To produce **bold text**, surround it with either `__two underscores__` (producing `<b>` in HTML) or `**two asterisks**` (producing `<strong>` in HTML).

Bold + Italic
: To produce ***bold + italic text***, surround it with either `___three underscores___` (producing `<b><i>` in HTML), `***three asterisks***` (producing `<strong><em>` in HTML).

Underline
: To produce ____underlined text____, surround it with `____four underscores____` (producing `<u>` in HTML). This is gross, but it's a tradeoff for Markdown compatibility: the one, two and three underscore choices were taken. Thankfully, it's usually preferable to use italic instead of underline. However, underline is not just a typewriter version of italics. In some languages, underlining serves a distinct, legitimate purpose.

Strikethrough
: To produce ~~strikethrough text~~, surround it with `~~two tildes~~`. This is the same syntax as is used by both [GitHub Flavored Markdown](https://help.github.com/articles/github-flavored-markdown/) and by John Macfarlane's excellent [pandoc](http://johnmacfarlane.net/pandoc/README.html).)

W> TODO_LEANPUB - add strikethrough to Leanpub

Superscript
: To produce superscript like the 3 in 5^3^ = 125, surround it with carets like `5^3^ = 125`. (This is the same syntax as is used by pandoc.)

Subscript
: To produce subscript like the 2 in H~2~O, surround it with single tildes like `H~2~O`.

Note that if the asterisks and underscores needed to produce bold and italic are not nested correctly, they will be output as asterisks and underscores instead of producing formatting. This includes combinations like `**_this**_`, `*__this*__` or `__*this__*`.

[^w3c_em]: To learn about the hilarious issues around bold and italic text in HTML and why there are two ways of producing bold and italic text in Markua, see the Appendix [The W3C and Semantic Emphasis](#w3c_semantic_emphasis).

## Whitespace, Paragraphs and Blank Lines

Together, newlines, spaces and tabs are called whitespace. By a newline, I mean the character which is produced by the enter key on the keyboard. Two newlines in a row produce a blank line, i.e. a line with no text or whitespace on it.

Paragraphs and blank lines are handled the same way in Markua and Markdown. Normal Markua text is in paragraphs. A paragraph produces a `<p>` tag in HTML. The distinguishing thing about a paragraph is that there is nothing else distinguishing about it: unlike headings, lists and other Markua elements, a paragraph requires no special formatting. To create a new paragraph, you add two newlines to create a blank line. Any extra number of newlines are ignored: two newlines in a row is equivalent to three (or ten!) newlines in a row.

Here's an example of this in Markua syntax. Throughout this specification, examples of Markua syntax will be shown as a figure which is a text resource, so that the exact Markua manuscript text can be shown unprocessed by a Markua. These are three paragraphs in Markua, each separated by the canonical two newlines which produce one blank line:

```
I'm paragraph one. Yay!

This is paragraph two.

This is paragraph three.
```

A paragraph is the least-specialized example of something called a block element. Broadly speaking, Markua documents consist of three things: block elements, span elements and metadata. All block elements that are separated by at least one blank line from other block elements, and that are not some specialized type of block element (like a heading, figure or list) are paragraphs.

## Newlines, Indentation and Spaces

The goal for newline and indentation handling in Markua is for everything to just work. Prose, poetry, code and figures should just work. There should be no surprises. Above all, no invisible formatting characters can be used.

In this regard, Markua has broader design goals than Markdown: Markdown is for web writers; Markua is for *writers*. Markdown is a format for authors to write HTML; Markua is a format for authors to write books and documents, of which HTML is just one format. The concepts in Markdown are HTML concepts; the concepts in Markua are book and document concepts.

Because of this, the way that single newlines and leading spaces are handled in Markua is different from the way that they are handled in Markdown.

### Single Newlines

In Markdown, a single newline inside a paragraph is interpreted as a single space. To add a forced line break (a `<br/>` tag in HTML), Markdown uses a horrible hack: you need to add two spaces at the end of the line, followed by a single newline. This means that it is **impossible** to look at a Markdown document with single newlines in it and understand what they mean: you need to find out if there are invisible formatting characters at the end of the line! Worse, in some text editors (like Emacs, the editor I use), trailing spaces at the end of a line are automatically removed when a file is saved. So, it's possible for me to inadvertently modify the meaning of a Markdown document by simply opening it and saving it! Also, in Markdown, it's impossible to type a sonnet without relying on the two space hack at the end of every line to force a newline--which isn't very poetic at all.

In Markua, a single newline inside a paragraph forces a line break, which produces a `<br/>` tag in HTML. This is true without any invisible formatting nonsense. As you will see, there are many types of block elements in Markua, including paragraphs, asides, blurbs, callouts, blockquotes and headings. A single newline inside most of these block elements produces a forced line break, and what follows is either still part of the same block element or is contained in the block element. However, headings (discussed later) are block elements, but inside a heading, a single newline is interpreted as a single space by Markua. This is because a heading is intended to be all on one line.

### Leading Spaces (Prose vs. Poetry)

In Markua, leading spaces are interpreted based on context: specifically, based on what came before them.

Following **exactly one** newline, whitespace is **preserved**. Specifically, a single space produces a single space (a "non-breaking" space, or `&nbsp;`, in HTML), and a single tab produces four spaces (four "non-breaking" spaces, or `&nbsp;&nbsp;&nbsp;&nbsp;`, in HTML).

Following **two or more** newlines (one or more blank lines), whitespace is **ignored**. So, you can manually indent your paragraphs if you're used to doing so, and it will have no effect.

This distinction also helps Markua support prose and poetry without a bunch of special syntax.

Two (or more) newlines in Markua create a new paragraph in prose, or a new stanza in poetry. That's it. Paragraphs can either be indented or not indented, but this is a global setting at the book or document level--not something that is specific to a given paragraph. Authors may choose to indent their paragraphs in their manuscript based on personal preference or habit, but this should have no effect on whether the paragraphs are indented in the output.

One newline, on the other hand, is used to add a forced line break, but to keep the existing paragraph (or stanza). Because of this, any leading space after a single newline is not paragraph indentation, but is instead deliberate indentation on the specific line. As such, it should be respected.

This means you can write a sonnet without typing any special formatting characters. In the following Markua text, every line break will be added correctly, and the last two lines will be indented:

```
I grant I never saw a goddess go;
My mistress when she walks treads on the ground.
    And yet, by heaven, I think my love as rare
    As any she belied with false compare.
```

In Markdown, not only would you lose the indents on the third and fourth lines, but without any trailing space hack used this would all be collapsed to one line! (Note how this shows that the two space hack is unacceptable: you should be able to tell what output is produced by looking at the input.)

More generally, the rules about single and double newlines mean that in Markua you can just write poetry without any formatting characters. Stanzas are separated with a blank line, and any indentation is preserved except on the first line of a stanza.

### Trailing Spaces are Stripped

Unlike Markdown, all trailing spaces at the end of a line are ignored by Markua. This way, there is no reliance on invisible formatting characters, and editors which strip trailing spaces have no effect on a Markua document.

### Internal Spaces are Collapsed to One Space

Like Markdown, in Markua, spaces or tabs that are in the middle of a line of text are collapsed to a single space. In Markdown, the main reason for this is presumably that this is how things work in HTML (without using `&nbsp;`). In Markdown, the reasons for this are that it's consistent with Markdown, and that it lets authors write books using either one or two spaces after a period, with there being no difference in the formatting.

Because of this, if you want to write poetry like e e cummings in which the exact spacing is preserved in leading and internal spaces, you need to use a text resource. Markua defines many different types of resources, including math, code and text resources. Resources are discussed later in this chapter.

### One Blank Line is Added When Concatenating Manuscript Files

A Markua document can be written in one file or multiple manuscript files. If a manuscript is written in multiple files, these files are concatenated together by the Markua processor to produce one temporary manuscript file, and that one file is used as the input. Importantly, in order to avoid a number of bugs, the files are not just concatenated together unchanged--they **must** be concatenated together by Markua Processors with **two newlines** added between the end of each file and the beginning of the next file. This is needed in order to separate the content of the two files with one blank line between them, in order to prevent a number of surprises for authors. Note that because of this rule, a paragraph (or any other block element) cannot span multiple manuscript files.

To see why this rule is important, consider the following single-file Markua manuscript:

W> TODO_LEANPUB - add caption support to Leanpub

{caption: manuscript.txt}
```
# Chapter One

Lorem ipsum dolor.

# Chapter Two

Yada yada yada.
```

Suppose instead a multiple-file approach was used, in which there were two files, ch1.txt and ch2.txt, with the following content:

{caption: ch1.txt}
```
# Chapter One

Lorem ipsum dolor.
```

{caption: ch2.txt}
```
# Chapter Two

Yada yada yada.
```

If Markua did not add any newlines between files, then these files would produce the following manuscript:

{caption: Incorrect Temporary Auto-Created Manuscript #1}
```
# Chapter One

Lorem ipsum dolor.# Chapter Two

Yada yada yada.
```

If Markua only added one newline when concatenating, this would produce the following manuscript:

{caption: Incorrect Temporary Auto-Created Manuscript #2}
```
# Chapter One

Lorem ipsum dolor.
# Chapter Two

Yada yada yada.
```

However, since Markua requires that headings be separated by blank lines above and below them, the `# Chapter Two` heading would not be a heading. It would be considered part of the previous paragraph! This would be very surprising and the source of a number of bugs. Worse, since a number of text editors such as Emacs have a "strip blank lines at the end of files" setting, it would be possible to introduce such a bug if Markua simply relied on blank lines being added to the end of a file by the author.

So, because of the blank line rule, concatenating the files produces the same manuscript as the single-file manuscript above:

{caption: Correct Temporary Auto-Created Manuscript}
```
# Chapter One

Lorem ipsum dolor.

# Chapter Two

Yada yada yada.
```

## Resources

Markua books and documents are written in plain text, either in one text file or multiple text files. However, modern books and documents are not just text. Books and documents embed many types of *resources*. These resources have traditionally included things like images, computer code listings and mathematical equations. More recently, with the development of ebooks and formats like EPUB3, ebooks have gained the ability to embed audio and video resources. Markua's goal is to make inserting all types of resources simple and consistent, while staying as close to Markdown's syntax as possible.

Resources vary in four different ways:

1. **Insertion Methods**: Span and Figure
2. **Locations**: Local, Web and Inline
3. **Types**: `image`, `video`, `audio`, `code`, `math` or `text`
4. **Formats**: `png`, `m4a`, `mp3`, `ruby`, `latex`, `plain`, etc.

There are six types of resources: `image`, `video`, `audio`, `code`, `math` and `text`. Each `type` of resource has a number of supported formats. Any of the six resource types can be inserted as a local resource or web resource, and many of the resource types can also be inserted as an inline resource.

Before going into more detail, it's helpful to consider some brief example of Markua text which shows a number of resources being inserted. These resources have different insertion methods (span and figure), different locations (local, web and inline), different types (image, code) and different formats (png, jpg, ruby)--yet the syntax to insert them is compact and consistent:

~~~
Inserting a span image is as easy as `![pie](pie.png)`. Inserting an image as a figure is also...

![A Piece of Cake](http://markua.com/cake.jpg)

Inline code resources are added as spans like `hello world` or as figures:

```ruby
puts "hello world"
```

{type: code, format: ruby}
![Hello, World](hello.rb)
~~~

The last figure in the example above showed an attribute list, which is a list of key-value pairs in curly braces. Any figure can have an attribute list, regardless of resource location, type or format.

If you're familiar with Markdown syntax, you'll note that the syntax for local and web resources is similar to Markdown's inline image insertion syntax, and that the syntax for inline resources is similar to the fenced code blocks syntax from popular Markdown extensions including GitHub Flavoured Markdown.

A> Markdown's reference style image syntax is not supported in Markua for *any* type of resource--including images.
A>
A> There are two main reasons for not supporting reference style resource syntax in Markua:
A>
A> 1. Resources in Markua are complex enough without having two syntaxes.
A> 2. In something as large as a book, the potential for id collisions in link definitions using the reference link syntax is a lot higher than in the blog post length of typical Markdown documents.

### Resource Insertion Methods

Resources can be inserted either as spans or as figures.

#### Spans

When a resource is inserted as a span, the resource is inserted as part of the flow of text of a paragraph with no newlines before or after it. A span resource cannot have an attribute list.

The syntax for a local resource or a web resource inserted as a span is as follows:

```
It's just ![optional alt text](resource_path_or_url) right in the text.
```

The optional alt text is discussed shortly.

The syntax for an inline resource inserted as a span is as follows:

```
It's a single backtick `followed by inline resource content\`optional_format and then a single backtick.
```

For example:

```
This is `puts "hello"`ruby a code resource with a format of `ruby`.

This, however, is a `puts "hello"` text resource inserted as a span.
```

#### Figures

When a resource is inserted as a figure, the resource is inserted with at least one newline before and after it. A figure can have an attribute list. A figure can either be top-level (with a blank line before and after it), or it can be part of the flow of text of a paragraph (with a single newline before it, and one or more newlines after it).

The syntax for a local resource or a web resource inserted as a figure is as follows:

```
{key: value, comma: separated, optional: attribute_list}
![Optional Figure Caption](resource_path_or_url)
```

Note that if there is a figure caption specified in the attribute list and in the square brackets, the one in the attribute list wins. In the following figure, the caption would be "Foo" not "bar":

```
{caption: Foo}
![bar](foo.png)
```

The syntax for an inline resource inserted as a figure is as follows:

~~~
{key: value, comma: separated, optional: attribute_list}
```optional_format
inline resource content
```
~~~

Note that if there is a format specified in the attribute list and after the backticks, the one in the attribute list wins. In the following figure, the format is `text` not `ruby`:

~~~
{format: text}
```ruby
puts "hello world"
```
~~~

A figure can also have attributes. The supported attributes vary based on the `type` of resource, but all figures support the following three attributes: `type`, `format` and `caption`.

`type`
: This is the resource type. It can be one of `image`, `video`, `audio`, `code`, `math` or `text`.

`format`
: This is the resource format. Different resource types have different legal values for format.

`caption`
: This is text which is shown near the figure, typically above or below it.

Many resource types can also have alt text. Alt text is not the same thing as a figure caption.

### Alt Text and Figure Captions

Some resources support alt text. Alt text is text which is intended to take the place of the resource if the resource itself cannot be seen. In the case of images, the obvious use case is for readers with visual disabilities who are using a screen reader, but it also includes audiobooks and ebook readers which often do not support embedded images, audio and video.

The four types of resource which can have alt text are `image`, `video`, `audio` and `text`. Resources of type `code` or `text` are themselves just text, so it makes no sense for them to have alt text. If any alt text is provided for a `code` or `text` resource it is ignored.

A> The alt text should **not** be the same thing as the figure caption, if the figure caption is present. (Imagine the annoyance of having a visual disability and having your screen reader read identical alt text and figure captions to you throughout an entire book!) Instead, the alt text should be descriptive of the image content, while the figure caption can be more creative. For example, a figure caption may be "Washington Crossing the Delaware" and the alt text could be "Denzel Washington riding a jet ski in a river". Having good alt text would enable readers who cannot see the image to still get the joke which the figure caption makes.

The syntax to provide alt text varies based on the resource location and insertion method.

#### Span + (Local or Web)

The alt text for a local or web resource inserted as a span is provided in square brackets before the resource path or URL:

```
It's just ![optional alt text](resource_path_or_url) right in the text.
```

Here's an example:

```
This needs to ![a stop sign](stop.png) now.
```

If you omit the optional alt text with a local or web resource, you still need to type the square brackets:

```
This needs to ![](stop.png) now.
```

#### Span + Inline

Alt text is not supported for inline span resources. There's no good syntax, and almost no real use case (with the exception of an inline span SVG image). If you want alt text in a span resource, use a local or web resource instead.

#### Figure

The alt text for a resource inserted as a figure is provided in the attribute list above the figure. This is true regardless of whether the resource location is local, web or inline, as shown in the following examples:

```
{alt: "The Delaware state map"}
![Where To Incorporate](delaware.svg)

{alt: "Denzel Washington on a jet ski in a river"}
![Washington Crossing the Delaware](delaware.jpg)

{alt: "Denzel Washington on a jet ski in a river", caption: "Washington Crossing the Delaware"}
![](delaware.jpg)

{caption: "Earth From Space (Simplified)", alt: "a blue circle"}
```svg
<svg width="20" height="20">
  <circle cx="10" cy="10" r="9" fill="blue"/>
</svg>
```

Note that as shown above, the caption for a figure can be provided either in the metadata or in the square brackets in front of a local or web resource.

#### Context-Sensitive Meaning of Square Bracketed Text

You may have been surprised reading this section. Markua does not have many inconsistencies, but this is one of them: the optional text inside the square brackets with a local or web resource varies based on whether the resource is inserted as a span resource or as a figure!

{caption: Meaning of the Text Inside Square Brackets}
|------------------|-----------------------------|
| Insertion Method | Text in Square Brackets is  |
|------------------|-----------------------------|
| Span             | The Alt Text                |
| Figure           | The Figure Caption          |
|------------------|-----------------------------|

The reason for this inconsistency is that even though it's a bit harder to learn, it's much better for writers this way once they've learned it.

The square brackets contain the text which is the most common use case for both span resources and for figures.

For a span resource, that is the alt text. For a figure, that is the figure caption.

This is especially true since a span image cannot have a figure caption, and since not all figures are of resource types that can have alt text. (Code resources and text resources are themselves text, so they cannot have alt text.) Also, many image, audio and video resources are inserted without alt text.

So, given this rule, a figure which is an external code sample can be inserted as either:

```
![My Amazing Algorithm](algorithm.rb)

{caption: "My Amazing Algorithm}
![](algorithm.rb)
```

The first choice is clearly shorter, as well as more pleasant to write and to read. With the square bracketed text being the figure caption for figures, both ways are supported. If the square-bracketed text was alt text in figures, then only the longer, unpleasant second choice would be supported.

Note that the second choice is how you add captions to figures which are inline resources, since there are no square brackets to use:

~~~
Here's a paragraph before the figure.

{caption: "My Amazing Algorithm}
```ruby
puts "hello world"
```

Here's a paragraph after the figure.
~~~

### Resource Locations

A resource is either considered a local, web or inline resource based on its location:

Local Resource
: The resource is stored along with the manuscript--either in a `resources` directory on a local filesystem, or uploaded to the same web service where the manuscript is being written.

Web Resource
: The resource is referred to via an `http` or `https` URL.

Inline Resource
: The resource is defined right in the body of a Markua document.

#### Local Resources

If local resources are used, all local resources must be stored inside a `resources` directory, or one of its subdirectories. The `resources` directory is not part of the path to the resource. Implementors of Markua Processors must ensure they do not support navigating upward with `../` in paths.

A file called `foo.jpg` in the `resources` directory is referenced as `![](foo.jpg)`--not as `![](/foo.jpg)`, `![](resources/foo.jpg)` or  `![](/resources/foo.jpg)`.

A file called `bar.png` in a subdirectory `images` of the resources directory is referenced as `![](images/bar.png)`--not as `![](/images/bar.png)`, `![](resources/images/bar.png)` or  `![](/resources/images/bar.png)`.

Markua does not specify whether there are any subdirectories of the `resources` directory, or what their names are. Since any subdirectories have their names as part of the path to the resource, implementations can do whatever they want. For example, Leanpub creates subdirectories of the `resources` directory for every type of resource (`images`, `audio`, `video`, `code`, `math` and `text`), but this is not a requirement.

The local resources approach can also be used by hosted services. Internally, services can store resources wherever they want, but if they provide a download (say as a zip file) they should create the resources directory and provide the uploaded resources in that directory. If a nested structure is used, it should be exported that way--if a web service produces paths which reference images inside an images directory (e.g. as `images/foo.png`), then the zip file centaining an export should contain a `resources` directory which contains an `images` subdirectory with the images.

#### Web Resources

If web resources are supported, both `http:` and `https:` resources should be supported.

Web resources are identified by URL. The `resource_path_or_url` is either the relative path to the resource inside the `resources` directory or the absolute URL of the resource on the internet. In the case of image, audio and video resources, this becomes the `src` attribute of the resource in HTML.

#### Inline Resources

Inline resources can be of type `code`, `math` or `text` (regardless of format), and they can also be `image` resources of `svg` format (since an SVG image is just XML text, it can be pasted in the text of a Markua document--something that is not true with binary images like PNG or JPEG, which can only be local or web resources).

### Resource File Extensions

Local and web resources often have a file extension. If a file extension is present, it is used to infer the default type and format for the resource.

Certain file extensions **must** be associated with a specific type of resource. These are specified in the sections below for images, video, audio, math and text.

Markua does not specify any file extensions associated with the `code` type. There are so many programming languages in the world, and new ones are added so frequently, that doing so would be impractical. If a Markua Processor recognizes a particular file extension as that of a particular programming language's source code, it can interpret it as a type of `code` with the appropriate format.

Markua also does not specify how Markdown (which often has a file extension of `.md`) or Markua (which often has a file extension of `.markua`) text should be interpreted by default. It can be interpreted as a type of `text` and a format of either `plain` (for normal text) or `monospaced` (for monospaced text). Note that if Markdown or Markua text is in a file with an extension of `.txt` it is interpreted by default as plain (not monospaced) text.

Markua Processors are free to interpret all unspecified file extensions however they want. New programming languages are invented constantly, and new image, audio and video formats are also created intermittently. For example, a Markua Processor could interpret all unspecified file extensions as type of `text` and a format of `monospaced`--this would ensure that all such files looked like source code which was not syntax-highlighted.

When a local or web resource is inserted as a span, the file extension is the only way to provide the type and format. When a local or web resource is inserted as a figure, the default type and format can be overridden by a type and/or format specified in the attribute list.

If the `type` and/or `format` is specified in an attribute list (in the case of a figure), the specified value(s) override the default value inferred from the file extension.

The behaviour varies based on what is specified in the attribute list:

* If only the `type` is specified, and it matches the type inferred from the `format`, the Markua Processor must interpret the format as what was inferred.
* If only the `format` is specified, the Markua Processor must infer the `type` from the specified format.
* If both the `type` and `format` are specified, the Markua Processor use them. If they are not a legal combination of type and format (e.g. type = `video`, format=`latex`), the Markua processor must pick the type based on the `format`.

### Resource Types and Formats

There are six types of resources: `image`, `video`, `audio`, `code`, `math` and `text`.

Each `type` of resource has a number of supported formats, which can either be specified by the `format` attribute or (in most cases) inferred from the file extension for local and web resources. (Inline resources obviously have no file extension, since they are contained in the body of a Markua manuscript file.)

Any of the six resource types can be inserted as a local resource or web resource, and many of the resource types can also be inserted as an inline resource.

The default `type` of a local resource or web resource is always `image`. This means images in Markua are inserted in essentially the same way they are in Markdown.

The default `type` of an inline resource depends on the `format` specified:

* If the format is `svg`, the inline resource is assumed to be of type `image`.
* If the format is `latex` or `mathml`, the inline resource is assumed to be of type `math`.
* If the format is omitted or is `plain`, the inline resource is assumed to be of type `text`.
* For any other format, the inline resource is assumed to be of type `code`.

These defaults mean that Markua can usually do the right thing based on the format, and that the resource type can almost always be inferred for inline resources. Markua is intended to be pleasant to write, so that means eliminating verboseness by using sensible defaults wherever possible.

Resources have different default attributes based on their type, format and insertion method. These default attributes are important, especially for resources inserted as a span, since they cannot have an actual attribute list--only resources inserted as a figure can have an attribute list. The specific default attributes are discussed in the sections below about the different resource types.

We will now consider each of the types of resources in more detail, as well as the various formats that they support.

#### Images

The most common type of resource in most Markua documents will probably be `image`. Like any resource, an image can be inserted as a span or as a figure.

The following types of images are supported in Markua: GIF, PNG, JPEG, SVG and zipped SVG.

{caption: "Resource File Extensions Associated With Images"}
|-----------|---------|------------|---------------|
| Extension | `type`  | `format`   | Description   |
|-----------|---------|------------|---------------|
| `.gif`    | `image` | `gif`      | GIF image     |
| `.png`    | `image` | `png`      | PNG image     |
| `.jpg`    | `image` | `jpeg`     | JPEG image    |
| `.jpeg`   | `image` | `jpeg`     | JPEG image    |
| `.svg`    | `image` | `svg`      | SVG image     |
| `.svgz`   | `image` | `svgz`     | Zipped SVG    |
|-----------|---------|------------|---------------|

W> TODO_LEANPUB - Support table captions (there should be one in the table above)

W> This specification is being rewritten. Do not trust anything after this point.

The syntax to insert an image is the same compact and consistent syntax that is used for any resource. Local and web resource locations are supported for any type of image; inline resource locations are supported for SVG images only.

The following examples show images being inserted as spans and as figures.

##### Local Images

Span:

~~~
Easy as `![pie](pie.png)`.
~~~

Figure:

~~~
Here's a paragraph before the figure.

{alt: "a slice of chocolate cake"}
![A Piece of Cake](cake.jpg)

Here's a paragraph after the figure.
~~~

##### Web Images

Span:

~~~
Easy as `![pie](http://markua.com/pie.png)`.
~~~

Figure:

~~~
Here's a paragraph before the figure.

{alt: "a slice of chocolate cake"}
![A Piece of Cake](http://markua.com/cake.jpg)

Here's a paragraph after the figure.
~~~

#### Inline Images (SVG only)

Span:

~~~
Red `<svg width="10" height="10"><rect x="0" y="0" width="10" height="10" fill="red"/></svg>`svg square.
~~~

Figure:

~~~
Here's a paragraph before the figure.

{caption: "Earth From Space (Simplified)", alt: "a blue circle"}
```svg
<svg width="20" height="20">
  <circle cx="10" cy="10" r="9" fill="blue"/>
</svg>
```

Here's a paragraph after the figure.
~~~





The file extension will be used to determine the default type of a local or web image.

However, in the case of figures, the type can also be specified via a `type` attribute in the attribute list. (If present, the `type` attribute overrides the default type inferred from the file extension.)


, except for span images that are local or web images.

The format of an image can be specified in metadata when an imp

~~~

The default attributes for an image inserted as a span are:

```
{type: image, align: left, float: none, position: here, width: auto, height: auto}
```

The default attributes for an image inserted as a figure are:

```
{type: image, align: center, float: none, position: near, width: auto, height: auto}
```

Image resources that are inserted as a span cannot have an attribute list--they must use the default attributes.

Markua supports five formats of local and web `image` resources: `gif`, `jpeg`, `png`, `svg` and `svgz`. While the format can be specified by a `format` attribute, for images that are local or web resources it can also be inferred by the file extension: `.gif` for GIF, `.jpg` or `.jpeg` for JPEG, `.png` for PNG, `.svg` or `.xml` for SVG, and `.svgz` for SVGZ (zipped SVG).


SVG images can also be inserted using Markua's inline resource syntax, which is normally used for code samples or math.

TODO


The supported attributes for `image` resources are: `align`, `float`, `position`, `width` and `height`. These affect how an image is sized and positioned. The defaults are: `{align: center, float: none, position: near, width: auto, height: auto}`.

The `align` is the horizontal alignment. It can be `center` (the default), `left` or `right`.

The `float` can be `none` (the default), `left`, `conter` or `right`. The `float` trumps `align`. If `float` is anything except its default of `none`, the value of `align` is ignored and the resource is positioned according to the value of the `float`, with the text flowing freely around it.

The `position` refers to vertical positioning on a page. The position only has an effoct on PDF generation -- it is ignored in EPUB and MOBI. It can be `near` (the default), `here`, `top` or `bottom`. The `near` position means to position the image near here, while the `here` position means to position the image exactly here. The `top` position means the top of the page; the `bottom` position means the bottom of the page. (If you're familiar with LaTeX, `near` is similar to `h` and `here` is similar to `H` or `h!`. Note that Markua deliberately does not specify anything about PDF output, to maximize implementation flexibility and encourage competition.)

The `width` and `height` can both be `auto`, `fullbleed` or an integer between `1` and `100` inclusive. The default is `auto`, which means to respect the actual size of the image without overflowing into page margins. If only one of `width` and `height` are `auto`, the image aspect ratio is respected; if both `width` and `height` are specified, the image is resized accordingly. The value of `fullbleed` means to resize the image to full width or height of the page, ignoring margins. It is legal for either one or both of `width` and `height` can be `fullbleed`. The integer values between 1 and 100 are percentage widths of the content area of the page.

These are some local and web image resources:

```
![map of Delaware](delaware.svg)

{width: 80, position: top, alt: "Denzel Washington on a jet ski in a river"}
![Washington Crossing the Delaware](delaware.jpg)

Many startups are ![happy](http://markua.com/happy.png) to incorporate in Delaware.
```


Doing the following will insert an SVG image of a blue circle:

~~~
This is a paragraph.
This is also a paragraph.
~~~

Images can be inserted as a span image in the flow of text in a paragraph. When an image is inserted as a span image, it must be positioned where it is inserted -- it cannot be floated and repositioned by Markua processors.

A span image cannot have a caption. If a caption is present, a Markua processor will ignore it. (A Markua processor may add a warning to the list of warnings which are reported in book generation, but no warning is added to the text itself.)

A> The reference style image syntax of Markdown is **NOT** supported in Markua.

#### Video

{caption: "Resource File Extensions Associated With Video"}
|-----------|---------|------------|---------------|
| Extension | `type`  | `format`   | Description   |
|-----------|---------|------------|---------------|
| `.mp4`    | `video` | `mp4`      | MP4 video     |
| `.webm`   | `video` | `webm`     | WebM video    |
|-----------|---------|------------|---------------|

Unlike with images which are supported in most circumstances, with audio or video files it's currently a bit of a crapshoot. With audio, there are MP3, AAC, Ogg and WAV formats all in widespread use, and there are a number of other formats with supporters. With video, there's currently a dominant proprietary format (H.264, or .mp4) and a new open source challenger (WebM). It's entirely likely that for a given ebook reader, any given audio or video format will not be supported, and as an ebook author you should be prepared to provide a fallback audio or video resource format and/or a fallback image for situations (including print books) where a audio or video resource will never work.

A> Obviously, embedding audio and video does not work for printed books and documents. It also won't work in many ebook readers and some ebook formats. However, for the applications (e.g. high school and first year university textbooks) where audio and video would be useful, it would be really, really useful.

Markua supports two types of `video` resourcess: MP4 and WebM. The video type is determined by file extension: `.mp4` for MP4, and `.webm` for WebM.

The supported attributes for `video` resources are: `poster`, `align`, `float`, `position`, `width` and `height`.

The `poster` is the URL or path to an image which should be shown instead of the video before the video is played. If a Markua Processor is outputting a print book or some format where it is known that video resources are not supported (including if the video is a web resource and web resources are not supported for video), it must choose the poster to use as a replacement for the video.

The `align`, `float`, `position`, `width` and `height` attributes work exactly how they do for images. They apply to the image specified by the `poster` attribute.

Examples:

```
Here's a video:

{type: video, poster: http://img.youtube.com/vi/VOCYL-FNbr0/mqdefault.jpg}
!["Introducing Markua](https://www.youtube.com/watch?t=105&v=VOCYL-FNbr0)

Ironically, I'm writing this sentence almost a year after that was recorded, and I still haven't figured everything out about Markua.
```

Markua supports MP4 and WebM videos. The videos must have the correct file extension for their type.

The supported file extensions for video files are:

.mp4
: The file is treated as an MP4 video.

.webm
: The file is treated as a WebM video.

If a Markua Processor is outputting a format in which particular types of audio or video resources are not supported, a missing audio or video image placeholder must be output. The look of this missing audio or video image is not specified in Markua; it can either be deliberately ugly (like the missing image icon in web browsers circa 1995) or it can be attractive.

If a Markua Processor is outputting a print book or some format where it is known that video resources are not supported, it must choose the poster to use as an image replacement. (This includes situations where the video is identified by a URL and only local video resources are supported by the particular Markua Processor.)

When inserting an audio or video resource as a span element in the flow of a paragraph, Markua Processors will want to use a very small (possibly emoji-sized) thumbnail for the audio or video resource. Otherwise, the paragraph would quickly look ridiculous, as a typical audio or video resource thumbnail is many times the height of a typical line of text.

A> For those familiar with HTML5 video: the `mediagroup` syntax and/or the use of `source` elements is not supported in Markua.

#### Audio

{caption: "Resource File Extensions Associated With Audio"}
|-----------|---------|------------|---------------|
| Extension | `type`  | `format`   | Description   |
|-----------|---------|------------|---------------|
| `.mp3`    | `audio` | `mp3`      | MP3 audio     |
| `.m4a`    | `audio` | `aac`      | AAC audio     |
| `.aac`    | `audio` | `aac`      | AAC audio     |
| `.wav`    | `audio` | `wav`      | WAV audio     |
| `.wave`   | `audio` | `wav`      | WAV audio     |
| `.ogg`    | `audio` | `ogg`      | Ogg Vorbis    |
| `.oga`    | `audio` | `ogg`      | Ogg Vorbis    |
|-----------|---------|------------|---------------|

Markua supports four types of `audio` resources: MP3, AAC, WAV and Ogg Vorbis. The audio type is determined by file extension: `.mp3` for MP3, `.m4a` and `.aac` for AAC, `.wav` and `.wave` for WAV, and `.ogg` and `.oga` for Ogg Vorbis.

There are no supported attributes for `audio` resources.

Examples:

```
The talk highlights are here:

{type: audio}
![](audio.mp3)

A longer version is on the web here:

{type: audio}
![](http://markua.com/fulltalk.m4a)
```

Markua supports MP3, AAC, Ogg and WAV audio files.

The supported file extensions for audio files are:

.mp3
: The file is treated as MP3 audio.

.m4a, .aac
: The file is treated as an MP4 AAC (Advanced Audio Coding) audio file. Note that .mp4 is not supported as a file extension for MP4 AAC audio, since that is the file extension used for MP4 video.

.wav, .wave
: The file is treated as a WAV (Waveform Audio File Format) file.

.ogg, .oga
: The file is treated as an Ogg Vorbis file.

#### Code

Code resources can be inserted either from external files (as local or web resources) or in the text of the document inline resources.

~~~
{type: code, format: ruby}
![](hello.rb)

{format: ruby}
```
puts "hello"
```
~~~

~~~
{type: code, format: guess}
![](hello.rb)

{format: ruby}
```
puts "hello"
```

```guess
puts "hello"
```

```text
puts "hello"
```

```
puts "hello"
```
~~~

In the settings, have a default format? choices: guess, plain, ruby, etc. Maybe default language too?

~~~
{type: code}
```svg
<svg width="50" height="50">
  <circle cx="25" cy="25" r="20" fill="blue"/>
</svg>
```
~~~

~~~
{type: image}
```svg
<svg width="50" height="50">
  <circle cx="25" cy="25" r="20" fill="blue"/>
</svg>
```
~~~


```ruby
puts "hello"
```

```text
puts "hello"
```

{type: image}
```svg
```

Code blocks can be defined inline or can import external code samples. Many attributes work the same way in both cases. The inline code block approach will be shown first.

{class: warning}
B> TODO - reference attribute list thing here, need to have a list of every element and attribute in appendix etc etc

You can create an inline code block by surrounding it using three backticks (`\``).

(You can also create an inline code block by surrounding it with three tildes (`~~~`), but the only reason this alternative exists is to enable writing about Markua code blocks that are surrounded with backticks in Markua. The correct approach in normal cases is to use three backticks.)

Here's an example of a code block:

~~~
```
def foo
  2
end
```
~~~

W> The "four space indent" method of creating code blocks in Markdown is not supported in Markua.

Since we force a blank line to end a list and since we force delimiters at the beginning of each list item, there's no reason to indent anything to make it part of the list item. It is part of the list item unless the list is over. Code blocks and multiple paragraphs can be added in single list item by newlines.

Markua also supports defining the language that a code sample is written in using the GitHub Flavoured Markdown style language specification, in which the language name is added after the three opening backticks that start a code block:

~~~
```ruby
def foo
  2
end
```
~~~

Markua Processors may guess at the language of a code block. To explicitly turn this off for a give code block, it can be forced to be plain text like this:

~~~
```text
def foo
  2
end
```
~~~

If a Markua Processor knows how to format the code using the specified language (if it has a "lexer" for it), it can do so. Otherwise, it must format the code using plain text as though `text` was specified as the language.

Note that this language definition is just a shorthand for a more general metadata feature of markua called attributes. Briefly, attributes comma-separated key-value pairs enclosed in a pair of curly braces (`{` ... `}`) and separated by a newline but **not** by a blank line from the thing that they are an attribute of.

You can define the language of a code block explicitly using the language attribute:

~~~
{format: ruby}
```
def foo
  2
end
```
~~~

Markua also supports adding other information to attributes of code blocks. For example, you can explicitly turn line numbering on an off using the `line-numbers` attribute:

~~~
{format: ruby, line-numbers: off}
```
def foo
  2
end
```
~~~

You can mix-and-match the attribute syntax and the GitHub-style syntax. The following is legal in Markua:

~~~
{line-numbers: on}
```ruby
def foo
  2
end
```
~~~

If the attribute and the GitHub-style syntax conflict, the attribute wins. The following will be formatted as plain text, not ruby:

~~~
{format: text, line-numbers: on, number-from: 3}
```ruby
def foo
  2
end
```
~~~

A> Line Wrapping
A>
A> Code blocks should have newlines added by the author to ensure that automatic line wrapping is not relied upon. Markua Processors must wrap lines to ensure that all code is visible, and *may* add continuation characters (like the backslash `\` character) in the output to indicate that a line has been automatically wrapped. However, adding a continuation character is not a requirement.

{class: warning}
B> TODO: possibly support {format: `asciiart`} on a code block, which tightens line spacing and turns off page breaks so that ASCII art looks better.

A> In Leanpub Flavoured Markdown, the paths included `code/`. This was redundant, since all code had to live in the code directory. So, Markua omits `code/` from the path.


External code samples can also have attributes added to them on import. These can set a caption, determine what subset of the code example to show, as well as set the line number to start the numbering on.

The following will show a code sample with the caption of "My Brilliant Algorithm". The code sample will contain 6 lines (lines 10-15 inclusive), and it will number them 10, 11, 12, 13, 14 and 15 since those are the line numbers of the given lines in the file:

```
{caption: "My Brilliant Algorithm", format: ruby, crop-start: 10, crop-end: 15, line-numbers: on}
<<(sample1.rb)
```

If this is not desired, you can choose to start the numbering wherever you want with `number-from`. Choosing `1` is a good choice.

The following will show 6 lines (lines 10-15 inclusive), and it will number them 1, 2, 3, 4, 5 and 6:

```
{format: ruby, crop-start: 10, crop-end: 15, line-numbers: on, number-from: 1}
<<(sample1.rb)
```

Or, if you wish to make things annoying, you can number from any non-negative integer you want. The following will show 6 lines (lines 10-15 inclusive), and it will number them 3, 4, 5, 6, 7 and 8:

```
{format: ruby, crop-start: 10, crop-end: 15, line-numbers: on, number-from: 3}
<<(sample1.rb)
```

A> The Leanpub Flavoured Markdown syntax of putting a code sample caption is not supported. This syntax looked like the alt text on images, but as discussed there, this was an incorrecct use of the image syntax.

#### Math

{caption: "Resource File Extensions Associated With Math"}
|-----------|---------|------------|---------------|
| Extension | `type`  | `format`   | Description   |
|-----------|---------|------------|---------------|
| `.tex`    | `math`  | `latex`    | LaTeX math    |
| `.mathml` | `math`  | `mathml`   | MathML math   |
|-----------|---------|------------|---------------|

You can put mathematical equations in your book, in either block elements (described below) or in span elements.

Blah blah `puts "hello"`ruby blah blah.

Blah blah `puts "hello"`text blah blah.

Blah blah `x = 2`math blah.

LaTeX math is `math`, MathML is `mathml`.

```math
```

```mathml
```

{format: math}
```
```

{format: mathml}
```
```

TODO


W> TODO: RESOURCE INSERTION REWRITE

Note that since these are span elements, LaTeX math will look a lot better than MathML.

This uses the default math engine. Chances are if you're using this syntax, you're using LaTeX math.

```
The four kinematics equations are `d = v_i t + \frac{1}{2} a t^2{/$$}, {$$}v_f^2 = v_i^2 + 2 a d`latex, `v_f = v_i + a t{/$$} and {$$}d = \frac{1}{2}(v_i + v_f) t`latex.
```

Markua processors can output do whatever they want here as well.

To create a math block, you insert it like a code block and you add a `math` attribute. The key is `math` and the value can either be `latex`, `mathml` or some other term.  This value specifies the markup language of the Math block.

**Markua procesors do NOT need to support any given Math markup language.**

##### LaTeX Math

However, if a Markua processor does not understand a given Math markup language specified by the value of a `math` attribute (say, if it supports LaTeX math but not MathML), it **MUST** output the content of the math block **as a code block formatted as text**.

To add LaTeX math, use `{type: math, format: latex}`:

~~~
Here is some paragraph text.

{type: math, format: latex}
```
\left|\sum_{i=1}^n a_ib_i\right|
\le
\left(\sum_{i=1}^n a_i^2\right)^{1/2}
\left(\sum_{i=1}^n b_i^2\right)^{1/2}
```

Here is some more paragraph text.
~~~

Markua processors can do whatever they want here. They can even output the entire thing as an image and insert the image, since that works on the most legacy ebook readers. Accessibility for old devices and accessibility for people with visual disabilities are often in conflict, and it's up to the Markua Processor to decide what to do.

##### MathML Math with `{math: mathml}`

To add MathML math, use `{math: mathml}`:

A> MathML is not supported in Leanpub, so we have no idea if supporting it is a good idea or not.

~~~
Here's an example from [Wikipedia](http://en.wikipedia.org/wiki/MathML):

{type: math, format: mathml}
```
<apply>
  <plus/>
  <apply>
    <times/>
    <ci>a</ci>
    <apply>
      <power/>
      <ci>x</ci>
      <cn>2</cn>
    </apply>
  </apply>
  <apply>
    <times/>
    <ci>b</ci>
    <ci>x</ci>
  </apply>
  <ci>c</ci>
</apply>
```

Here is some more paragraph text.
~~~

Markua processors can do whatever they want here as well.

Note that there is a default markup language for math in a Markua document. It is determined by the value of the `math` attribute which is set in the metadata. The default value of the `math` attribute is `latex`.

Because of this, you can also insert math like this:

~~~
Here is some paragraph text.

```math
\left|\sum_{i=1}^n a_ib_i\right|
\le
\left(\sum_{i=1}^n a_i^2\right)^{1/2}
\left(\sum_{i=1}^n b_i^2\right)^{1/2}
```

Here is some more paragraph text.
~~~

Markua processors can do whatever they want here as well.

A> For the programmers reading this: since resources cannot themselves include resources, you cannot have cycles resulting in infinitely long Markua documents.

#### Text

{caption: "Resource File Extensions Associated With Text"}
|-----------|---------|------------|---------------|
| Extension | `type`  | `format`   | Description   |
|-----------|---------|------------|---------------|
| `.txt`    | `text`  | `plain`    | Plain text    |
|-----------|---------|------------|---------------|

Poetry, either plain text poetry or monospaced "typewriter poetry" is just a text resource.


There are many different types of resources, which are discussed at length shortly. However, it's helpful to discuss text resources now, since they are how poetry is supported in Markua.



If you want to write poetry where the whitespace (including indentation) matters, you need to surround the poem in three tildes or three backticks. As you'll see in the Resources section, three tildes and backticks have different defaults: three tildes defaults to `plain` format text, whereas three backticks defaults to `monospaced` format text.

The three tildes syntax can be useful to indent sonnets where the indentation matters, but otherwise looks like normal text:

```
~~~
I grant I never saw a goddess go;
My mistress when she walks treads on the ground.
    And yet, by heaven, I think my love as rare
    As any she belied with false compare.
~~~
```

The three backticks syntax can be useful to write monospaced poetry like e e cummings:

~~~
```
i am a cat
                        a        l a z y          cat
         me   ow
```
~~~


If you want to write poetry where the whitespace matters, you need to surround the poem in three tildes or three backticks. As you'll see in the Resources section, three tildes and backticks have different defaults: three tildes defaults to `{type: text, format: plain}` and three backticks defaults to `{type: text, format: monospaced}`.


If you want to write poetry where the whitespace matters, you need to surround the poem in three tildes (`~`) or three backticks (`\``). As you'll see in the Resources section, three tildes and backticks have different defaults: three tildes defaults to {type: text, format: plain} and three backticks defaults to {type: text, format: monospaced}.

The three tildes syntax can be useful to indent sonnets where the indentation matters, but otherwise looks like normal text:

```
~~~
I grant I never saw a goddess go;
My mistress when she walks treads on the ground.
    And yet, by heaven, I think my love as rare
    As any she belied with false compare.
~~~
```

The three backticks syntax can be useful to write monospaced poetry like e e cummings:

~~~
```
i am a cat
                        a        l a z y          cat
         me   ow
```
~~~

## Lists

Markua defines substantially more list types than Markdown. In Markdown, the only types of lists supported are ordered lists with decimal numbers and unordered lists. However, since Markua does not support inline HTML, and since Markua is used for producing books and documents, Markua must define more types of list.

Specifically, the following types of lists are supported:

1. Unordered Lists
2. Ordered Lists
3. Definition Lists

For ordered lists, the following numbering choices are supported:

a. Decimal numbers
b. Uppercase letters
c. Lowercase letters
d. Uppercase Roman numerals
e. Lowercase Roman numerals

Definition Lists are discussed in the next chapter--although they are called lists, they're very different than unordered and ordered lists.

A> Despite the fact that all lists actually have an order (otherwise they would not be lists!), Markua is sticking with the HTML terminology for "ordered" vs. "unordered" lists, instead of "numbered" vs. "bulleted" lists. Even though these feel more like programming terms, HTML terminology is so widely understood that using any other terminology is distracting. (Also, since the ordered lists support numbering by decimal numbers, letters and Roman numerals, this term is superior to numbered lists in that regard.)

If you are familiar with Markdown, as you read the sections below you will note a number of differences between Markua lists and Markdown lists.

### Embedding Lists, Figures and Code Blocks Inside a Paragraph

TODO: incorporate this somewhere.



{#unorderedlists}
### Unordered Lists (i.e. Bulleted Lists)

Just as in Markdown, Markua lets you start an unordered list with three types of bullet:

1. asterisks (`*`)
2. hyphens (`-`)
3. plus signs (`+`)

(If you didn't know you could use `-` and `+` to start an unordered list in Markdown, now you do. The more you know.)

To make an unordered list in Markua, you start one or more consecutive lines with one of these bullets, followed by between 1 and 4 spaces or 1 tab, followed by text content.

A list can be top-level, like this:

```
Here's a paragraph before the list.

* foo
* bar
* baz

Here's a paragraph after the list.
```

Unlike in Markdown, in Markua a list can also be nested in a paragraph, like this:

```
This is paragraph one.

This is paragraph two.
  * foo
  * bar
  * baz
This is still paragraph two.

This is paragraph three.
```

Embedding a list in a paragraph works for all types of list, but you need to indent the list with some amount of whitespace.

Here's how unordered lists work:

* The preferred bullet type for an unordered list in Markua is the asterisk (`*`). However, all three bullet types are supported, since this would be a huge change for not that good of a reason.
* Between 1 and 4 spaces or one tab is allowed after each bullet.
* You cannot mix tabs and spaces: if a tab is used after a bullet, tabs must be used after each bullet.
* If spaces are used after each bullet, the same number of spaces MUST be used after each bullet in the list.
* A varied number of spaces or tabs or a mixture of tabs and spaces does not create an unordered list. Instead, it creates a paragraph with line breaks inside it, which produces break tags in HTML.
* The preferred amount and type of whitespace after the bullet is one space.
* The bullet type used is output as a class in the HTML, so that designers can optionally use CSS to vary the style of bullets based on the bullet type used by the author.
* A single element unordered list is a list: although it is a pretty stupid list, treating it as a literal paragraph starting with an asterisk, plus or hyphen would be even stupider.

{#ordered_lists}
### Ordered Lists (i.e. Numbered Lists)

Ordered lists are more fully featured in Markua than in Markdown.

Unlike in Markdown, in Markua **the number that begins the list in the manuscript is the number that begins the list in the output**.

Also, in Markua, an ordered list can vary the following:

1. Numbering system
  a. Decimal numbers
  b. Uppercase letters
  c. Lowercase letters
  d. Uppercase Roman numerals
  e. Lowercase Roman numerals
2. Numbering direction (ascending or descending)
3. Initial number (or letter, or Roman numeral)

W> TODO - this list above renders wrong until we support nested lists in Markua

To make an ordered list in Markua, you start one or more consecutive lines with either a consecutive number or the same number (or letter or roman numeral), followed by between 1 and 4 spaces or 1 tab, followed by text content:

```
before

1. foo
2. bar
3. baz

after
```

Since Markua supports letters and Roman numerals as well as decimal numbers to start lists, the rules about using consecutive numbers or the same number are actually a bit complex.

Note that there are one or more spaces after the period. Unlike with an unordered list, the number of spaces does not need to be the same after each item (since numbers may have 2 or more digits, so a variable number of spaces may be desired to line everything up).

A> I had really wanted to support parentheses after the number as well as periods, since to me `a)` looks a lot better than `a.` does. However, there's no *good* way to do this in HTML, so I'm giving up and not doing it. If you make a lettered list with parentheses, it just turns into a paragraph with a bunch of newlines for the list items, so you basically get what you want, just not using HTML constructs.

This set of examples shows the normal use cases of lists with the various numbering systems. For the edge cases, see the next sections.

#### In Markua, A Single Element Ordered List is Not a List

Markdown has the interesting combination of supporting one element lists and ignoring the number that a list starts with. This means it's possible to inadvertently start a numbered list by beginning any line with a number followed by a period. The example that John Gruber [cites](http://daringfireball.net/projects/markdown/syntax) is the following:

`1986. What a great season.`

This would produce a single element numbered list starting with `1.` -- which in my opinion, is a blatant violation of the Principle of Least Surprise.

Now, in Markua, if we supported single element ordered lists, this would produce a single element numbered list starting with `1968.` -- which would be almost as bad as in Markdown.

(By the way, there is a very gross workaround in Markdown: you prefix the period with a backslash. So, you'd write `1968\. What a great season.` to avoid this.)

But what to do?

The answer is simple: in Markua, **single element ordered lists are not lists**. This is true for ordered lists only -- single element unordered lists and single element definition lists are both lists. (In the case of an unordered list it's stupid, but the alternative is stupider. In the case of a definition list there's actually a legitimate usage of a single element definition list: a single definition.)

To me, the notion of a *list* is something with more than one thing in it. If I have a list of chores to do, there are many of them. If I have one chore to do, I don't call it a list of chores--I call it a chore.

So, in Markua, the automatic creation of an ordered list only happens if you have two or more lines starting with numbers and periods.

This still has some possibly incorrect interpretations, but these will be a lot more rare. This matters: if you get burned by the automatic list creation, and you feel that you have to think about whether you can start a sentence with a number, then writing in Markua will feel more like programming than writing.

A> This is a microcosm of the difference between Markua and Markdown: since Markdown is a way of producing HTML, it is biased toward producing HTML constructs wherever it is most straightforward to do so. Markdown is a way of writing books and documents, and it only produces HTML constructs like lists when it is almost certainly appropriate to do so. So, whereas Markdown tries to make HTML wherever possible, Markua respects what the author wrote, and only substitutes HTML constructs where doing so is lossless in the text (period and parentheses are not equal) and unambiguous (a single element is probably not a 1 element list).

### Ordered List Numbering Rules

A> If you are an author who is just trying to write straightforward Markua, you can probably skip this section.

There are a number of rules about what does and does not trigger the creation of an ordered list. These rules are designed to help authors stay sane when writing in Markua, and also to help implementors of Markua processors stay sane. In all cases, the first number, letter or Roman numeral is the start of the list numbering. This never changes.

If, because of the correct application of these rules, an ordered list is not created, what happens is that a paragraph is created instead, with a break tag for each single newline. In this instance, the output directly matches the input, including all the numbering.

In theory, Markua supports creating an ordered list when either of the following two conditions occur:

1. Every item in the list begins with a consecutive number, either increasing or decreasing.
2. Every item in the list begins with the same number.

This is not actually quite true.

See, the notion of "consecutive" is easy to explain and to check for decimal numbers, either in increasing or decreasing order. `1, 2, 3, ...`, `456, 457, 458, ...`, or `5, 4, 3` are all easily verified as consecutive, both by humans and computers.

However, Markua also supports ordered lists using uppercase and lowercase alphabetical numbering, as well as uppercase and lowercase Roman numeral numbering, and in increasing or decreasing order.

In the case of alphabetical numbering, checking "consecutive" is harder. It's relatively straightforward for the first 26 items, but then all bets are off. In case you're curious, here is the sequence used in HTML for increasing alphabetical numbering:

`a, b, ..., z, aa, ab, ..., az, ba, bb, ... bz, za, zb, ..., zz, aaa, aab, ..., aaz, aba, abb, ...`

In terms of Roman numerals, it's even worse. I'm sure that someone in a Classics department (or in the NFL) knows the algorithm by heart, but I don't.

So, what are Markua authors and implementors of Markua processors to do?

Markua makes this simpler by specifying the following rules.

Markua *actually* supports creating an ordered list based on a different set of conditions based on the numbering type.

For decimal numbers, Markua actually supports creating an ordered list when either of the following two conditions occur:

1. Every item in the list begins with a consecutive number, either increasing or decreasing.
2. Every item in the list begins with the same number.

For uppercase and lowercase alphabetical numbering, Markua actually supports creating an ordered list when either of the following two conditions occur:

1. Every item in the list begins with a consecutive letter, followed by a period, and the lettering does not extend past `z.` for lowercase or `Z.` for uppercase. (This way, implementors of Markua processors don't need to check the `aa`, case, and authors writing in Markua don't need to remember it.)
2. Every item in the list begins with the same single letter, followed by a period.

The term "single letter" means that consecutive `c.`s start an ordered list which starts with `c, d, e, ...`, but that consecutive `aa.`s or `aba.`s do not start an ordered list. Again, this greatly simplifies life (you're welcome!) for implementors of Markua processors, who otherwise would need to figure out what number in the sequence `aba` is, in order to generate the correct HTML.

For uppercase and lowercase Roman numeral numbering, Markua actually supports creating an ordered list when either of the following two conditions occur:

1. Every item in the list begins with a consecutive Roman numeral, followed by a period, and the lettering does not extend past `xii.` for lowercase Roman numerals or `XII.` for uppercase Roman numerals. To be clear, this means that the only valid consecutive lowercase Roman numerals are `i, ii, iii, iv, v, vi, vii, viii, ix, x, xi, xii`, and that the only valid consecutive uppercase Roman numerals are `I, II, III, IV, V, VI, VII, VIII, IX, X, XI, XII`.
2. Every item in the list begins with `i.` for lowercase Roman numerals or `I.` for uppercase Roman numerals.

The combination of the rules for Roman numeral numbering means that you can have an arbitrarily long Roman numeral list starting from `i.` or `I.`, but that implementors of Markua processors don't need to write code to figure out whether `MCMLXXV` is a valid Roman numeral, and what the consecutive Roman numeral sequence after it is.

If you're wondering why I picked `xii` and `XII` for the last consecutive lowercase and uppercase Roman numerals to respect: this is Roman numeral 12, and the main usage of Roman numerals in modern life is in clock faces.

Speaking of clock faces, I have bad news for fans of watches and antique clocks:

* The only supported version of the Roman numeral 4 is the subtractive `iv` (in lowercase) or `IV` (in uppercase); the additive `iiii` or `IIII` form is not supported.
* The only supported version of the Roman numeral 9 is the subtractive `ix` (in lowercase) or `IX` (in uppercase); the additive `viiii` or `VIIII` form is not supported.

It turns out that the question of additive versus subtractive forms of Roman numerals is actually interesting; see [this article](http://mentalfloss.com/article/24578/why-do-some-clocks-use-roman-numeral-iiii) and [this Wikipedia entry](https://en.wikipedia.org/wiki/Roman_numerals) for a starting point.

In Markua, list numbers must **all** either be **consecutive**, given the type of numbering  that is used, or **the same as the first number**. Otherwise, the list is interpreted as a paragraph with a bunch of break tags in it, and lines starting with the numbers given. The principle is the following: the numbers which are shown in the manuscript must be the same as those in the output, or the numbers must be clearly intended to be numbered list numbers. Otherwise, a list will not be produced.

If you want to prevent a list from being created with consecutive numbered items separated by single newlines, the backslash escape in front of the period used in Markdown to prevent lists also works in Markua. However, it is needed a lot less often.


{#headings}
## Definition Lists

A> While Definition Lists are called lists, they're a very different type of animal from unordered and ordered lists. So, they're treated separately.

Definition lists are supported in Markua. Although [some people](http://meta.stackexchange.com/questions/72395/is-it-possible-to-have-definition-lists-in-markdown) don't see the value in definition lists in HTML, we strongly believe in their value. Specifically, with the rise of mobile and the narrower screen reading experience becoming the new default, we see definition lists as having more of a future than tables. But instead of just being two columns, the idea of a definition list has actual meaning.

To define a definition list in Markua, use the following syntax:

```
term 1
: definition 1

term 2
: definition 2
```

The term cannot start with a square bracket--this is reserved for the reference-style image syntax.

A definition list can define multiple definitions for a term:

```
term 1
: definition 1a
: definition 1b

term 2
: definition 2
```

Note that a single term definition list is a definition list, regardless of how many definitions for the term exist.

```
term
: definition
```

For an example of a longer, more useful definition list used in Markua, see the definitions section of this specification.




## Headings

Markdown is a way of writing HTML, and HTML has 6 heading levels: `h1`, `h2`, `h3`, `h4`, `h5` and `h6`.

Markua, however, is a way of writing books and documents. Books have things like chapters, sections and subsections. Sometimes books have parts. Documents have sections and subsections. What Markua does is use the heading levels that Markdown uses to create HTML to create the structure of the book or document, as well as generating the `h1` through `h6` heading levels in the HTML version of the book.

Markua is also a lot more strict about heading syntax than Markdown.

In Markdown, there are two syntaxes for making headings, atx and Setext, and [both of them can take many forms](http://daringfireball.net/projects/markdown/syntax#header). However, **in Markua there is exactly one way of making every type of heading**. It is a subset of the atx headings in Markdown.

Here's the only way that headings are made in Markua:

{#input_headings_1}
```
# Part (h1) #

This is a paragraph.

# Chapter (also h1)

This is a paragraph.

## Section (h2)

This is a paragraph.

### Sub-Section (h3)

This is a paragraph.

#### Sub-Sub-Section (h4)

This is a paragraph.

##### Sub-Sub-Sub-Section (h5)

This is a paragraph.

###### Sub-Sub-Sub-Sub-Section (h6)

This is a paragraph.
```

Specificaly, to create a Markua heading, you put the following on a line by itself, with a blank line above and below it:

* between one and six pound signs (`#`)
* followed by exactly one space
* followed by text
* followed (only for parts) by exactly one space and exactly one pound sign

Making these headings divides your book or document into these divisions. If you add part headings, your book will have parts; if you don't, it won't. If you add chapter headings, your book will have chapters; if you don't, it won't.

Note that in Markua, both parts and chapters produce an `h1`. This is mildly surprising, but entirely appropriate: For books which have no parts, the chapter is the topmost organizational unit. In a book with parts, it is more important for chapters to behave the same way that they do in a book without parts (i.e. to be created with `# Title` and to produce an `h1`) than to be correctly "contained" (if you think like an outliner) inside the Part.

Markua is more strict about spaces and pound signs than Markdown:

1. In Markua, to make a part heading you make a heading like `# Title #` -- the heading starts with exactly one a pound sign and exactly one space, and ends with exactly one space and exactly one pound sign. No other combination of pound signs and spaces makes a part heading.
2. Part headings end with a space and a pound sign, but other than that, headings cannot have optional pound signs at the end of them. Any other pound signs are considered to be text in the heading. (This is different than the atx headers in Markdown.)
3. All headings must start with between 1 and 6 pound signs (`#`) and then have exactly one space, followed by text. If any other number of spaces is used or if tabs are used, the text must be interpreted as a paragraph by a Markua Processor, not as a heading. (This ensures that Markua manuscripts look consistent for authors, and can be parsed more easily by Markua Processors.)
4. Headings must be separated from other block elements by blank lines both before and after them. Because of the way that Markua concatenates files, headings at the top of a Markua document automatically have a blank line above them, and headings at the bottom of a Markua document automatically have a blank line below them. So, headings at the top of a document only need a blank line below them, and headings at the bottom of a document only need a blank line above them.

I thought long and hard about Markua headings, and changed my mind (as Scott and Braden will attest) a number of times. I settled on this design when I realized that the design requirements were as follows:

1. From looking at a heading, an author must be able to know exactly what it is. It's not acceptable to need to reference metadata to know what the headings mean.
2. Only existing Markdown syntax can be used, to ensure that Markdown-aware tooling will work unchanged.
3. The number of leading pound signs must match the level of heading in HTML.
4. For a book with chapters only (no parts), the chapter headings must feel "top-level".
5. The syntax to create parts must be as economical as possible.
6. There must be only one way to create every level of heading. Headings structure Markua documents, and must be clear and unambiguous.
7. It should be possible to switch back and forth between having parts in your book without having to modify all existing headings.
8. Books with parts and chapters must be able to have the same number of levels of sub-sections.
9. Documents can have parts, chapters and sections just like books, and it's up to the document designer to create the appropriate CSS.

The design of Markua headings meets these requirements, in what I feel is an optimal way.

A> Leanpub Flavoured Markdown violated a number of these requirements, especially #2 (as parts were created with `-# Title`). Previous versions of Markua were even worse, violating many of these requirements (e.g. #1, #3, #4, #6, #7 and #8).

A> There are two primary issues with Setext headings in Markdown. First, it is inconsistent: you can only define `h1` and `h2`; to define h3 and below, the atx style of heading must be used. Second, it is confusing: it's unclear about how many equals or minus signs you need to use. (The answer is 1, which looks disgusting.) Also, it's unclear whether you need to add a blank line below the row of equals signs or minus signs, and whether a heading is still produced if this is not done.

## Tables

Markdown:
Give up and use HTML.

GFM:
https://help.github.com/articles/github-flavored-markdown/

PHP Markdown Extra:
https://michelf.ca/projects/php-markdown/extra/#table

Markua:

Easier to read. More features (rowspan, colspan, alignment of individual cells instead of just columns, etc). Harder to write, but who cares since (a) it's not that much worse and (b) there will be tooling.

```
| `.png`    | `image` | `png`      | PNG image     |
| `.jpg`    | `image` | `jpeg`     | JPEG image    |
| `.jpeg`   | `image` | `jpeg`     | JPEG image    |
```

```
| `.png`    | `image` | `png`      | PNG image     |
| `.jpg`    | `image` | `jpeg`     | JPEG image    |
| `.jpeg`   | `image` | `jpeg`     | JPEG image    |
```

```
| Extension | `type`  | `format`   | Description   |
|-----------|---------|------------|---------------|
| `.gif`    | `image` | `gif`      | GIF image     |
| `.png`    | `image` | `png`      | PNG image     |
| `.jpg`    | `image` | `jpeg`     | JPEG image    |
| `.jpeg`   | `image` | `jpeg`     | JPEG image    |
| `.svg`    | `image` | `svg`      | SVG image     |
| `.svgz`   | `image` | `svgz`     | Zipped SVG    |
```

```
|-----------|---------|------------|---------------|
| Extension | `type`  | `format`   | Description   |
|-----------|---------|------------|---------------|
| `.gif`    | `image` | `gif`      | GIF image     |
| `.png`    | `image` | `png`      | PNG image     |
| `.jpg`    | `image` | `jpeg`     | JPEG image    |
| `.jpeg`   | `image` | `jpeg`     | JPEG image    |
| `.svg`    | `image` | `svg`      | SVG image     |
| `.svgz`   | `image` | `svgz`     | Zipped SVG    |
|-----------|---------|------------|---------------|
```

```
|-----------|---------|------------|---------------|
| Extension | `type`  | `format`   | Description   |
|:----------|:-------:|-----------:|---------------|
| `.gif`    | `image` | `gif`      | GIF image     |
| `.png`    | `image` | `png`      | PNG image     |
| `.jpg`    | `image` | `jpeg`     | JPEG image    |
| `.jpeg`   | `image` | `jpeg`     | JPEG image    |
| `.svg`    | `image` | `svg`      | SVG image     |
| `.svgz`   | `image` | `svgz`     | Zipped SVG    |
|-----------|---------|------------|---------------|
```

```
|=====================|=================|=======================|=========================|
| Column Header 1     | Column Header 2 | Column Header 3       | Column Header 4         |
|:====================|:===============:|======================:|=========================|
| this is a rowspan   | this is a colspan of 2 columns          | sit amet                |
| of 2 rows since it  |-----------------|-----------------------|-------------------------|
| spans two rows      | ipsum           | dolor                 | sit amet                |
|---------------------|-----------------|-----------------------|-------------------------|
| lorem ipsum dolor   | ipsum           | dolor                 | sit amet                |
| sit amet            |                 |                       |                         |
|---------------------|-----------------|-----------------------|-------------------------|
| lorem ipsum dolor   | lorem ipsum     | dolor                 | lorem ipsum dolor sit   |
| sit amet lorem      | dolor sit amet  |-----------------------| amet lorem ipsum dolor  |
| ipsum dolor sit     | lorem ipsum     | dolor                 | sit amet                |
|--------------------:|:----------------|-----------------------|-------------------------|
| lorem               | ipsum           | dolor                 | sit amet                |
|                     |                 |                       |-------------------------|
|                     |                 |                       | sit amet                |
|                     |                 |                       |-------------------------|
|                     |                 |                       | sit amet                |
|:-------------------:|----------------:|-----------------------|-------------------------|
| lorem               | ipsum           | lorem ipsum dolor sit amet this is a colspan of |
|---------------------|-----------------| 2 columns and a rowspan of 2 rows since it      |
| lorem               | ipsum           | spans 2 columns and 2 rows                      |
|====================:|:================|:=====================:|=========================|
| lorem               | ipsum           | dolor                 | sit amet                |
|=====================|=================|=======================|=========================|
```

## ABC: Asides, Blurbs and Callouts

W> TODO - make executable etc

Need syntactic sugar for short asides and not to make life hell for long ones. An aside can have page breaks in it; a blurb cannot; a callout can but shouldn't if possible.

Callouts are blurbs that can be freely and creatively positioned near the manuscript position.  Asides and blurbs must be positioned at the manuscript position.

```
Syntax:

A> stuff

{aside}
stuff
{/aside}

B> stuff

{blurb}
stuff
{/blurb}

C> stuff

{callout}
stuff
{/callout}
```

Asides, blurbs and callouts can have an icon property. Markua processors that don't understand a given icon can ignore it.

There is some syntactic sugar for short blurbs with given classes. This sugar is specifically intended to help programming book authors.

Here's the sugar:

```
W> this is a warning blurb

T> this is a tip blurb

I> this is an info blurb

Q> this is a question blurb

these are equivalent to:

{class: warning}
B> this is a warning blurb

{class: tip}
B> this is a tip blurb

{class: info}
B> this is an info blurb

{class: question}
B> this is a question blurb
```

Besides this, there is support for adding arbitrary icons. Markua Processors can ignore these. Leanpub, for example, understands the icon attribute to reference an icon from Font Awesome. This is optional so that Markua processors can do creative things here, without worrying about breaking. If a Markua processor does not understand a given icon it must be silently ignored -- it is not acceptable to add a missing image or equivalent in it.

```
{icon: car}
A> you can't spell carbon without it

{icon: leanpub}
A> yes, we're in Font Awesome

{icon: github}
A> so is GitHub
```

Asides are text which is formatted separately from the main text by a Markua processor. Asides can span multiple pages.

Asides can be created like block quotes, but using `A>` line prefixes. The same rules for newlines apply.


Blurbs are like asides, but with two differences.

1. They are created with `B> ` not `A> ` prefixed lines.
2. They are intended to be short, and thus do not need to support page breaks inside them.
3. They can have an optional `class`, which can be used by Markua processors to decorate the blurb (e.g. with icons).


### Classes of Blurbs and Syntactic Sugar

Like all Markua block elements, blurbs can have a `class` attribute attached to them. Here's an example:

```
{class: warning}
B> Warning text. Don't do this!
B>
B> This is still part of the blurb. Note that the entire blurb gets the class element.
```

### Syntactic Sugar for Standard Blurb Classes

Markua has its origin in Leanpub, and Leanpub has its origin in authoring computer programming books.

In computer programming books, there are a number of blurb types which are a defacto standard:

* `discussion`
* `error`
* `exercise`
* `information`
* `question`
* `tip`
* `warning`

Having to constantly type `{class: warning}` in a computer programming book with a number of warnings would get tedious, as would any of the other blurb classes listed above.

So, Markua defines a standard shorthand syntax for these classes of blurbs. With this syntax, you use a different letter than `B` in the `B>`, to create a blurb with the appropriate class:

```
* `D>` for `discussion`
* `E>` for `error`
* `X>` for `exercise`
* `I>` for `information`
* `Q>` for `question`
* `T>` for `tip`
* `W>` for `warning`
```

W> TODO - sleep on this and decide if is this a good or bad idea to bring back ... With this and the `id` syntax question it's tempting to at least be consistent and either support both or just one, but it's odd to only do sugar for `id` and support both for blurb classes?!


There are no required CSS rules in Markua, and thus, there is no required special support for any specific class attributes on a blurb or anywhere else.

For example, Leanpub produces a lot of computer programming books, so it understands the following values for the `class` attribute on a blurb:

### Using Extension Attributes on Blurbs to add Icons

As discussed later, Markua blocks can support any number of extension attributes. An extension attribute is an attribute which is not part of the Markua specification.

Blurbs provide an example of an extension attributes.

Leanpub's Markua implementation supports an `icon` attribute on blurbs. The value of this attribute is assumed to be the name of an icon in Font Awesome, without the `fa-` prefix.  So, in Leanpub, you can do this:

```
This is a paragraph before the blurb.

{icon: automobile}
B> Len thinks that cars will all be driverless soon.
B>
B> Peter thinks that Len is right, but that (except in big cities) people will still own their own driverless cars.

This is a paragraph after the blurb.
```

In Leanpub, this will produce a nice icon of a car, using the Font Awesome icon. In a Markua implementation that does not understand the icon attribute, nothing will be generated for that attribute -- it will be functionally equivalent to the attribute not being present.

Let's see whether the Markua processor that produced this document understands the `icon` attribute:

{icon: automobile}
B> Len thinks that cars will all be driverless soon.
B>
B> Peter thinks that Len is right, but that (except in big cities) people will still own their own driverless cars.

If there was a car, it did; if there was no car, it did not.

## Block Quotes

Block quotes can span multiple pages. They are created by prefacing lines with `> `, i.e. a greater than character followed by a space.

A blockquote can contain other block-level elements, most commonly paragraphs. To start a new block level element within a blockquote, just put a line starting with a `>` followed by an optional space. It is equivalent to placing a `> ` in front of every line of the paragraphs.

Block quotes can be multi-paragraph. To create a multi-paragraph block quote, you need to separate each paragraph with a line containing a `>` and whitespace only.

Single newlines inside a block quote do not start new paragraphs. Instead, they simply add a line break, which produces a `<br/>` in HTML. This is identical to how single newlines inside a top-level Markua paragraph function.

A> The nesting of block quotes in Markdown is not supported in Markua.

A> Note that any headings inside block quotes, asides and blurbs do not show up in the Table of Contents. They can also be formatted differently by Markua Processors.

## Links

Markua's hyperlink support is a subset of that of Markdown. The **inline** link syntax is supported, as is the **automatic link** shortcut. The reference link syntax and the implicit link name shortcuts are **NOT** supported.

A> Markdown is a way of writing HTML designed by bloggers, and links are so plentiful in that medium that it makes some sense to support four syntaxes to create links. In ebooks, however, links are not as prevalent, so it makes sense to be opinionated here. Furthermore, in something as large as a book, the potential for id collisions in link definitions using the reference link syntax is a lot higher than in a blog post.

### Inline Links

The normal way to create a link is as follows:

```
[link text](absolute_url)
```

In Markdown, the URL can be either absolute or relative, since relative URLs can make sense on web servers. In Markua, however, all URLs must be absolute.

### Automatic Links

To create a link where the text displayed for the link text is the URL itself, the automatic link syntax can be used. In this syntax, an absolute URL is enclosed in angle brackets.

```
Some text <absolute_url> some text.
```

## Footnotes and Endnotes

{class: warning}
B> TODO

## Crosslinks and `id`s

There are two parts to making a crosslink.

1. Define an id.
2. Link to that id with a crosslink.

### Defining an `id` on Block and Span Elements, Using `{#some-id}` Syntax Only

To define an `id`, you create an `id` attribute on a block or span element.

If you use `id`s, chances are you use a *lot* of them. So, if Markua supported a syntax of `{id: some-id}`, you'd be typing that a *lot*. Instead, Markua defines a shorthand syntax of `{#some-id}` to define an `id` attribute.

W> This syntax of `{#some-id}` is the **only** way to define an `id`.

To define an id, just create an `id` attribute above a block element or attached to a span element.

### Defining an `id` on a Block Element

There are two ways to define an `id` on a block element.

First, using an `id` attribute:

```
{id: some-id}
This is a paragraph with the id of `some-id`.
```

Second, using a shorthand approach:

```
{#some-id}
This is a paragraph with the id of `some-id`.
```

### Defining an `id` on a Span Element

You can define an `id` on a span element. To do this, simply add an `id` attribute definition (either the explicit `{id: foo}` or the shorthand `{#foo}` version) in curly braces following any span element.

### Referencing an `id` With a Crosslink

Now, regardless of how you defined the id, you then link to it to create a crosslink. To do this, you use the `#` character and the id in a link:

```
[link text](#some-id)
```

This syntax is intended to be reminiscent of HTML anchor tags, not of `h1` titles in Markua.

Special rules:

* If a Markua document contains duplicate `id` attribute values, the first one is used and the subsequent ones are ignored. A Markua Processor should output a warning about duplicate `id`s.
* Crosslinks that reference an unused `id` may either be created as a (broken, non-functional) link or be created as normal text (not a link) by a Markua Processor. The Markua Processor may also output a warning about this somewhere, but not in the actual document text itself.

### Referencing Chapter, Section and Figure Heading Names and Numbers in Crosslinks

Chapters, sections and figures with captions often have two useful properties for writers:

1. A name which is often short and useful to reference.
2. A number, if numbering is turned on.

Whether the numbers exist is determined by the `number-chapters`, `number-parts` and `number-figures` attributes.

Here's how these references to titles and numbers work:

* `#t` is for "title"
* `#n` is for "number"
* `#d` is for "description" (e.g. "Figure", "Chapter", "Section", "Example")
* `#f` is for "full title"

So, for "Figure 8.2: Anatomy of a Squirrel", these are:

* `#t` is "Anatomy of a Squirrel"
* `#n` is "8.2"
* `#d` is "Figure"
* `#f` is "Figure 8.2: Anatomy of a Squirrel"

Note that in this example, "Anatomy of a Squirrel" was typed by the author, whereas "Figure 8.2: " was generated by the Markua Processor. It does not matter; both can be referenced.

Also, note that regardless of section level, sections referenced in `#d` or `#f` are all called "Section" (not "Sub-Section", "Sub-Sub-Section", etc.)

The expectation is that `#f` will be used by authors who don't mind verbosity, and #t and #n will be used by authors who prefer control and brevity. The #d is for very lazy authors who like saving keystrokes and/or who don't know whether their publisher will call the code samples "Listing", "Example" or some other word and want to protect themselves against extra work.

The `code-sample-names`, 'figure-names` and `table-names` settings control the words used to name things.

Examples:

`This is discussed in [section #n, #t](#crosslinks).`

`This is discussed in [#f](#crosslinks).`

`This is discussed in a [#d](#crosslinks) above.`

`See [chapter #n](#span-elements), which is the best chapter in this book.`

`This is in figure [#n](#fancy-diagram), arguably the fanciest diagram in this document.`

A> Figures, chapters, code samples, etc all have implicit numbering.  So, #n always works even if numbering is off.  You'll just confuse readers.  If numbering is off, the `#f` will not include either the `#d` or `#n` parts: it will be "Anatomy of a Squirrel" not "Figure 8.2: Anatomy of a Squirrel".

## Scene Breaks

In fiction, scene breaks are sometimes added between paragraphs in a chapter to denote a break in context.

To make a scene break, create a line which has only hyphens, asterisks or underscores on it, and which has at least three of them. There may be whitespace between the hyphens or asterisks. Scene breaks must have a blank line above them and below them.

Markua Processors can take great liberties in how they display scene breaks in non-HTML outputs. For example, scene breaks can be displayed as a few centered asterisks, an image, or just a blank line, depending on whether the book is fiction or another type of book.

Scene breaks map to the `hr` element in HTML.

## Soft hyphen

In certain rare situations, it's desirable to be able to give hints to a Markua Processor about where hypenation can be done.

This attribute makes us sad. However, it's a nod to reality. Hopefully this attribute is never used by authors writing the first draft of anything.

Soft hyphens are not output in HTML.

To insert a soft hyphen, used a backslash followed by a hyphen:

```
You can use soft hyphens to suggest where to break long words like Rumpel\-stiltskin if you wish.
```

{#metadata}
## Metadata

Markua uses metadata to provide a bunch of advanced functionality.

There are three types of metadata: attributes, index entries and directives.

Attributes are used to do everything from specify the language of code blocks, add ids for crosslinkng and even support extensions to Markua. Index entries let authors or indexers produce professional-looking indexes in Markua books. Finally, directives control


### TODO

A Markua document can be written in one file or multiple manuscript files.

In order to encourage competition, Markua does not specify much about how the single file or multiple files approaches must work.

If a manuscript is written in one file, any metadata (discussed later) is placed in a metadata block. This is typically at the top of the manuscript file, but it can be anywhere in the file or it can be located elsewhere, e.g. in the case of a web service.

If a manuscript is written in multiple files, the metadata is typically stored in its own file. Also, as the first step of book or document generation, a

The manuscript files are concatenated together by the Markua processor as the first step of book or document generation. If the multiple file approach is used, the listed files are first concatenated together by a Markua Processor to produce one temporary Markua manuscript file, and that one file is used as the input. Importantly, in order to avoid a number of bugs, the files are not just concatenated together simply--they must be concatenated together by Markua Processors with two newlines added between the end of each file and the beginning of the next file, in order to separate the content of the two files with one blank line between them. Because of this, a paragraph (or any other block element) cannot span multiple manuscript files.



For example, with multiple files, Leanpub's normal Dropbox workflow uses a hybrid approach where there is a file called book.txt which lists the files in the manuscript in order and in which most of the book settings are specified via a web interface. However, that is just one approach of many possible ones: Markua can be used for entirely web-based (also supported by Leanpub), or it could be a command line tool in which the files to be processed are listed in order (similar to pandoc).



### A Note About Curly Braces (`{` and `}`)

Metadata is added with curly braces. Curly braces are special in Markua. At the beginning of a line, an opening curly brace (`{`) starts an attribute. In the middle of a block element, an opening curly brace starts an index entry. And, at the top of a manuscript.txt file (if the single file approach is used), an opening curly brace starts a settings block. So, to use a curly brace as an actual curly brace character, you need to backslash-escape it like this: `\{`.

{#attributes}
### Attributes

Attributes are a type of metadata which can be used by Markua Processors to format output.

Attributes are a set of comma-separated key-value pairs enclosed in a pair of curly braces (`{` ... `}`) and separated by a newline--but **not** by a blank line--from the thing that they are an attribute of.

This shows a code block, with the attribute `language` having the value `ruby`:

~~~
{format: ruby}
```
def foo
  2
end
```
~~~

You can have more than one attribute. This shows a code block, with the attribute `language` having the value `ruby` and the attribute `line-numbers` having the value `off`:

~~~
{format: ruby, line-numbers: off}
```
def foo
  2
end
```
~~~

Attribute values can be enclosed in quotation marks. These are optional, and are only needed if the attribute value contains a comma. However, for clarity, it is recommended to use quotation marks for any attribute values which are not single words or numbers.

Here's the previous example, with the addition of quotation marks. This is identical to the previous example in meaning.

~~~
{format: "ruby", line-numbers: "off"}
```
def foo
  2
end
```
~~~

Attributes can also have numeric values. These are the same, with or without quotes:

```
{format: ruby, crop-start: 10, crop-end: "15", line-numbers: on}
<<(code/sample1.rb)
```

In this example, the numbers 10 and 15 are both treated as numbers.

If you wish an attribute to have a value that contains a quotation mark, you need to escape it.

Here's some fish that may not be very fresh:

```
{title: "\"Fresh\" Fish"}
Filet of salmon, on sale now!
```

Markua defines a few built-in attributes which have special meaning.

#### Standard Attributes

##### Defining `id` On Any Block, Using `{#some-id}` Syntax Only

As we saw in the section on crosslinks, attributes can be used to define ids on block elements.



Normally there is only exactly one way to do everything in Markua. However, for people who define a lot of `id`s, the `{id: ` syntax is much more cumbersome than the `{#` syntax, so we're giving a nod to power users of `id`s here by providing a shorthand.


There are two ways to do this:

```
{#some-id}
### Some Heading

{id: some-id}
### Some Heading
```

These are identical. The `{#some-id}` syntax is just syntactic sugar, which is convenient since it's possible to create a lot of id-only attributes.

Note that these syntaxes work for any block element, not just headings.

Here's the same syntaxes for paragraphs:

```
{#some-id}
This is a paragraph with the id of `some-id`.

{id: some-id}
This is a paragraph with the id of `some-id`.
```

By the way, you can only use an `id` once in an entire Markua document, even one that is split over multiple files. So choose your `id`s carefully.

You can also give `id`s to individual items in a list or definition list:

```
* lorem
* ipsum
{id: foo}
* foo
{#bar}
* bar
* baz
* dolor

term 1
: definition 1

{#term-2}
term 2
: definition 2

{id: term-3}
term 3
: definition 3
```

You cannot, however, give ids to things inside tables.

In terms of the value of an `id`, it has some special restrictions:

1. The first character in the `id` has to be a lowercase or uppercase letter, i.e. [a-zA-Z] if you think in regular expressions.
2. The remaining characters in the `id` have to be a lowercase or uppercase letter or a digit or a hyphen (-) or an underscore (_).
3. You can only use an `id` value once in an entire Markua document, even one that is split over multiple files.

These restrictions ensure that your `id`s can then be linked to by a crosslink from anywhere in the Markua document.

Finally, note that crosslinks will work even if the `id` has not been defined yet.

##### Attributes of Code Blocks

As we saw earlier, attributes can be used on code blocks. These include:

* `language`
* `crop-start`
* `crop-end`
* `line-numbers`
* `number-from`

{#extension-attributes}
#### Extension Attributes

An author can annotate any Markua block element with any attribute at all, not just those understood by all compliant Markua processors.

Markua processors which do not natively understand these additional attributes must silently remove them from all output formats.

1. Set them as attributes on the block element that is produced by the HTML output.
2. Silently remove them from all other output formats (e.g. EPUB, MOBI, PDF, LaTeX, etc).

TODO - differentiate between (strict and not strict) output modes (don't name it strict mode), and explain (in Leanpub we just have strict mode)


Any attribute not understood by a Markua processor must be set as an attribute on the block element that it is attached to in the HTML output only.

A Markua Processor should remove this not understood attribute from other output formats (e.g. LaTeX, EPUB) which are known to be more strict about unknown attributes.

Briefly, this means any Markua block element can be annotated with an attribute which is not built into Markua, and which Markua processors will probably not understand.

This encourages competition in the Markua ecosystem, while ensuring that Markua implementations do not choke on Markua input which goes beyond their capabilities.

This is an extension mechanism to allow for specialized uses of Markua: since CSS is so powerful, with creative uses of custom attributes and custom CSS, Markua documents can be transformed.

### Index Entries

Markua supports adding index entries as metadata.

Index entries can either be attached to block or span elements, using a curly brace syntax which is very similar to how `id`s are defined, using a syntax [inspired by LaTeX](https://en.wikibooks.org/wiki/LaTeX/Indexing).

So as to not conflict with the names of directives, all index entries start with `i:` (i is for index).

In its simplest form, an index entry is simply `{i:hello}`.

These are the various formats of an index entry:

```
{i:hello}
{i:*hello*}
{i:**hello**}
{i:hello!Peter}
{i:hello!*Peter*}
{i:hello!**Peter**}
{i:Peter|see{i:hello}}
{i:Jen|seealso{i:Jenny}}
```

Here's what they do:

`{i:hello}`
: Adds an index entry for `hello`.

`{i:*hello*}`
: Adds an index entry for `hello`, with `hello` in *emphasis*.

`{i:**hello**}`
: Adds an index entry for `hello`, with `hello` in **strong emphasis**.

`{i:_hello_}`
: Adds an index entry for `hello`, with `hello` in _italics_.

`{i:__hello__}`
: Adds an index entry for `hello`, with `hello` in __bold__.

`{i:hello!Peter}`
: Adds an index entry for `Peter` which is a sub-entry of `hello`.

`{i:hello!_Peter_}`
: Adds an index entry for `Peter` (with _Peter_ in italics) which is a sub-entry of `hello`. Note that this cannot be combined with a see or seealso (the | syntax).

`{i:hello!__Peter__}`
: Adds an index entry for `Peter` (with __Peter__ in bold) which is a sub-entry of `hello`. Note that this cannot be combined with a see or seealso (the | syntax).

`{i:hello!*Peter*}`
: Adds an index entry for `Peter` (with *Peter* in emphasis) which is a sub-entry of `hello`. Note that this cannot be combined with a see or seealso (the | syntax).

`{i:hello!**Peter**}`
: Adds an index entry for `Peter` (with **Peter** in strong emphasis) which is a sub-entry of `hello`. Note that this cannot be combined with a see or seealso (the | syntax).

`{i:Peter|see{i:hello}}`
: Adds an index entry for `Peter`, which references the index entry `hello` with the equivalent of "see" in the language of the book. Note that this cannot be combined with a sub-entry (the ! syntax).

`{i:Jen|seealso{i:Jenny}}`
: Adds an index entry for `Jen`, which references the index entry `Jenny` with the equivalent of "see also" in the language of the book. Note that this cannot be combined with a sub-entry (the ! syntax).

Index entries are case sensitive. For example, `{i:mark}` and `{i:Mark}` are distinct entries. (The first is for a result or a blotch on something, the second is a person's name.)

To attach an index entry to the start of a block, put it on its own line above a block:

```
{i:hello}
I just came to say hello, hello, hello, hello
```

(In this case, the index entry is identical in positioning to an id attribute definition.)

To attach an index entry to a word, just add the index entry after the word:

```
I just came to say hello{i:hello}, hello, hello, hello
```

To attach an index entry to a span element, just add the index entry after the span element:

```
The first program that a programmer writes in a language is usually *Hello World*{i:Hello World}
```

Index entries can have commas and other punctuation (except colons) in their definition:

```
My wife read some book about a whale by Herman Melville{i: Melville, Herman}.
```

Multiple index entries can exist in a block, or even a sentence:
```
Supposedly the great-great-great-granduncle of the musician Moby{i:Moby} was Herman Melville{i: Melville, Herman}, the author of a book about a whale{i:Moby-Dick; or, The Whale}.
```

### Directives

W> TODO - Define how directives and attrs that are not understood are handled, and explain how this does not include syntax like CriticMarkup which just get output verbatim if not understood. Also say that encountering CriticMarkup tags and outputting CriticMarkup is optional. Doing stuff inside curly braces which is not understood by Markua is OK, etc.

Directives function like switches which affect the future behaviour of a Markua Processor. Like attributes, they are contained in curly braces `{` ... `}`. Unlike attributes, instead of having a `key: value` pair, they just contain a keyword.

#### Book Section Directives

Most published books have three types of material in them: the front matter, the text and the back matter.

What authors write, the manuscript, is typically what goes into the text, or main matter, of the book. In style guidelines such as the Chicago Manual of Style this is called the text; in formats such as TeX and LaTeX it is called main matter.) It's what is numbered with Arabic numerals starting from 1.

There's a bunch of other stuff (the Dedication, Epigraph, Table of Contents (or ToC), Foreword, Preface, etc.) which comes before the text of the book. This is called "front matter". Some of the front matter comes before the ToC and is not numbered; the rest of the front matter that comes after the ToC gets numbered with Roman numerals.

There's also a bunch of other stuff (acknowledgments, appendices, the index, etc) which comes after the main matter. This is called the "back matter".

If Markua just relied on its headings support there would be no good way to accomplish the division of a manuscript into front matter, main matter and back matter. (We could try some convention about heading names, but that would be a highly objectionable, English-centric hack.) Furthermore, there would be no good way to determine which parts of the front matter got numbered and which did not.  Also, there would be no good way to give explicit hints to Markua processors about how to style the various parts of a book.

Book section directives are the solution to this.

Book section directives inform Markua Processors what section of a book they are in, in order to affect numbering, formatting and other concerns like the placement of the Table of Contents.

Markua is a fairly minimalist format, so we want to accomplish all of the above with as few directives as possible. Furthermore, for authors who do not know about these directives, we do not want anything bad to happen.

There are three types of book section directives:

1. Front Matter Book Section Directives: these directives delineate various sections in the front matter
2. The `{mainmatter}` directive: this indicates that the front matter is over
3. Back Matter Book Section Directives: these delineate various sections in the back matter

**You can write a book or document in Markua without using any directives at all, including book section directives.**

However, if you add any of the Front Matter Book Section Directives, the `{mainmatter}` directive is required.

Almost all of the directives will be added either:

a) by someone working for a publisher
b) automatically by book generation software

The only directives that a typical author will use are `{dedication}` and `{mainmatter}`.

A> For implementors of Markua Processors:
A> It is perfectly legal to ignore all of the book section directives. Book section directives are only hints that are there for your benefit if you want to use them to add page breaks, switch to hanging indents, change the font size, use a custom layout or to do anything fancy with them. There is no requirement to do any of these things.

Besides the `{mainmatter}` directive, there are named directives for each book section in the Chicago Manual of Style.

Note, however, that there are **no** `{frontmatter}` and `{backmatter}` directives. These are redundant, since there is a `{mainmatter}` directive. All book section directives before the `{mainmatter}` are in the front matter, and the first book section directive after the `{mainmatter}` directive starts the back matter.

The following is the entire list of book section directives, in the order they will typically be encountered. There is no requirement about any of their order; they are just hints. If you're familiar with the Chicago Manual of Style you'll recognize them.

##### Front Matter Book Section Directives

The following are the book section directives which can appear in the front matter.

`{half-title}`
: the book half title

`{series-title}`
: the series title (or frontispiece)

`{title-page}`
: the title page (note that if an image called `title_page.png`, `title_page.jpg` or `title_page.jpeg` exists it will be inserted as the first page of the book, but that any content in this section will also exist)

`{copyright}`
: the copyright page

`{dedication}`
: the dedication

`{epigraph}`
: the epigraph

`{toc}`
: the table of contents

`{figures}`
: the table of figures, or list of illustrations

`{tables}`
: the list of tables, or table of tables

`{foreword}`
: the foreword

`{preface}`
: the preface

`{acknowledgments}`
: the acknowledgments (note that this can also typically occur after the `{mainmatter}` book section directive)

`{introduction}`
: the introduction

`{abbr}`
: the abbreviations -- and yes, it's called `abbr` and not `abbreviations` (note that this can also typically occur after the `{mainmatter}` book section directive)

`{chronology}`
: the chronology (note that this can also typically occur after the `{mainmatter}` book section directive)

##### The `{mainmatter}` Book Section Directive

`{mainmatter}`
: the first page of the text

##### Back Matter Book Section Directives

`{appendices}`
: the appendix or appendices

`{notes}`
: the notes

`{glossary}`
: the glossary

`{bibliography}`
: the bibliography or references (note that a Markua processor may wish to format the text inside this section appropriately)

`{contributors}`
: the list of contributors

`{illustration-credits}`
: the credits for the illustrations

`{index}`
: the index(es)

##### Book Section Directive Rules

While these book section directives are mere hints, there are strict rules about their use:

1. Each book section directive must be on a line by itself.
2. Each book section directive must have a blank line above it, except at the beginning of a file.
3. Each book section directive must have a blank line below it, except at the end of a file.
4. Each book section directive can only appear once.
5. The book section directives are all optional; it is legal to have a Markua document with no Book Section Directives.
6. If any of the Front Matter Book Section Directives are present, the `{mainmatter}` directive is required.

The upshot of all this is that authors new to Markua can completely ignore directives. Only when they wonder how to make certain sections excluded from the numbering, or to have Roman numerals etc, do they have to worry about directives. And using directives is very simple, despite how formally specified this section makes them.

#### Directives That Are Not Understood Must Be Silently Ignored

Directives that are not understood by Markua must be silently ignored.

This has three consequences:

1. New directives can be added to future versions of Markua without a negative effect on older Markua implementations.
2. New versions of Markua can stop supporting directives in this version of Markua without needing to specify anything special.
3. Any line which starts with an opening curly brace `{`, contains one word (with hypens), and ends with a closing curly brace `}` is assumed to be a directive, and will not be output by a Markua processor.

##### Unsupported Leanpub Flavoured Markdown Directives

Markua is not supporting various Leanpub Flavoured Markdown directives which were added willy-nilly over the years. These directives being dropped include:

* `{begin-hanging-paragraphs}`
* `{end-hanging-paragraphs}`
* `{footnotes-on}`
* `{footnotes-off}`

{#settings}
### Settings

As discussed earlier, there are two ways that a manuscript can be structured:

1. Single File Approach: `manuscript.txt`
2. Multiple Files Approach: `book.txt`, `sample.txt` and `settings.txt`

With both approaches to structuring a manuscript, there is a way to provide metadata along with the manuscript.

The metadata contains information about the document. This will include things like the title, subtitle, copyright, author names, etc.

The metadata is provided in different ways based on whether the manuscript uses the single file approach or the multiple file approach.

#### Settings Are Just Newline-Separated Key-Value Pairs

As the title of this section states, Metadata is just newline-separated key-value pairs.

Here's an example of metadata:

```
title: Markua Specification
authors: Peter Armstrong
contributors: Scott Patten, Braden Simpson and Jordan Ell
copyright: Peter Armstrong
```

The format of the metadata is one entry per line, with the keys and values separated by a colon and a whitespace.

Any white-space at the beginning or end of the keys and values will be stripped. Only the first colon is important. Subsequent colons on a line will just be part of the value.

Where this metadata lives depends on which approach is used by the manuscript.

#### Settings in the Single File Approach: Inline in `manuscript.txt`

Markua manuscripts can be written all in one file called `manuscript.txt`. Since the goal of the one file approach is to have everything contained in one file for simplicity, this includes the metadata.

With this approach, all the metadata lives in one newline-separated hash at the top of the file. In the metadata hash, the keys must be added one per line: the hash is newline-separated, not comma separated. (The reason for this is to make it not look like an attribute list on an element.) Furthermore, there must be a blank line between this hash and the beginning of the file, to disambiguate between a settings hash and an attribute list.

Here's an example of what this file looks like including metadata:

```
{
title: Markua Specification
}

# Chapter One: Wisdom

Why Markua is so wise.
```

Here's another example, which shows why there must be a blank line between the metadata and the following content: so that it can also have attributes attached, and so that the metadata is not interpreted as being an attribute of the first element:

```
{
title: Markua Specification
authors: Peter Armstrong
contributors: Scott Patten, Braden Simpson and Jordan Ell
copyright: Peter Armstrong
}

{id: ch1}
# Chapter One: Wisdom

Why Markua is so wise.

# Chapter Two: Cleverness

Why Markua is so clever. By the way, it is also [wise](#ch1).
```

### Settings in the Multiple Files Approach: `settings.txt`

With the multiple-files approach, there is a separate file called `settings.txt` which contains the metadata.

Here's an example of the content of this settings.txt file:

```
title: Markua Specification
authors: Peter Armstrong
contributors: Scott Patten, Braden Simpson and Jordan Ell
copyright: Peter Armstrong
```

With this approach, the following files would make this equivalent to the single file above:

book.txt:

```
ch1.txt
ch2.txt
```

ch1.txt:

```
{id: ch1}
# Chapter One: Wisdom

Why Markua is so wise.
```

ch2.txt:

```
# Chapter Two: Cleverness

Why Markua is so clever. By the way, it is also [wise](#ch1).
```

{#setting-keys-and-values}
### Settings Keys and Values

The following keys can be used in the Metadata. None of theme are mandatory, although you will almost certainly want to provide a value for `authors`, `copyright` and `title`.

authors
: The authors of the Markua document. The default is "Anonymous".

code
: The language that code is. The default is `text`, which means no syntax highlighting should be used, but the code should be in a monospaced font suitable for a programming language. There are other options. The `guess` option means to guess at the code language based on the syntax encountered (or the file extension for external code samples). The `poetry` option means to format the code as monospaced poetry, such as would be produced on a typewriter. Besides these options, you can specify the programming language used, such as `ruby` or `java`. If a Markua processor does not recognize the programming language specified, it must format it as `text`.

code-sample-names
: What to call code samples. The default is "Example".

copyright
: The text of the copyright holder. The default is "Anonymous".

direction
: `rtl` or `ltr`. The default is `ltr`.

figure-names
: What to call figures. The default is "Figure".

filename
: The filename (minus extension) of the generated output file(s). The default is "untitled".

footnotes
: The way that footnotes should be displayed. The choices are `page`, `chapter` and `book`. The default is `page`. The `page` value means the bottom of the page (a footnote); the `chapter` value means at the end of the chapter (an endnote), and the `book` value means at the end of the book or document (an endnote).

language
: The IS0 639-2 alpha-3 language code of the language that the Markua document is written in. The list of choices is here: <http://www.loc.gov/standards/iso639-2/php/code_list.php>. The default is `eng`.

license
: The copyright license used. The choices are `standard`, `public-domain`, `cc-by`, `cc-by-sa`, `cc-by-nd`, `cc-by-nc`, `cc-by-nc-sa` and `cc-by-nc-nd`. The `standard` choice means standard copyright. The `public-domain` means that the work is considered to be in the public domain. The other choices are Creative Commons licenses, specified here: <https://creativecommons.org/licenses/>. The default value is `standard`.

math
: The default markup language used for math blocks and spans. The default is `latex`, but any value can be present. For MathML, the value is `mathml`. If the value is unrecognized, the Markua processor must output the math block or span as plain text.

number-chapters
: This attribute sets how chapter numbering is done. The values are `off`, `chapter`, `section`, `sub-section`, `sub-sub-section` and `all`. The default is `chapter`, which means to number chapters but not sections or below.

number-parts
: This attribute sets whether parts are numbered, if present. The values are `on` and `off`. The default is `on`, which means to number parts.

number-figures
: This attribute sets whether figures are numbered, if present. The values are `off`, `single` and `double`. The default is `double`. The choice `single` means to number figures in one large list (Figure 1, Figure 2, etc.). The choice `double` means to number by chapter, e.g. `Figure 8.1` for the first figure in chapter 8. Per Chicago, figures in an Appendix would be listed as `Figure A.1` for Appendix A, etc.

number-code-samples
: This attribute sets whether code sample code samples are numbered, if present. The values are `off`, `single` and `double`. The default is `double`. The choice `single` means to number code samples in one large list (Example 1, Example 2, etc.). The choice `double` means to number by chapter, e.g. `Example 8.1` for the first code sample in chapter 8. Per Chicago, code samples in an Appendix would be listed as `Example A.1` for Appendix A, etc.

number-tables
: This attribute sets whether tables are numbered, if present. The values are `off`, `single` and `double`. The default is `double`. The choice `single` means to number tables in one large list (Table 1, Table 2, etc.). The choice `double` means to number by chapter, e.g. `Table 8.1` for the first table in chapter 8. Per Chicago, tables in an Appendix would be listed as `Table A.1` for Appendix A, etc.

subtitle
: The subtitle of the Markua document. The default is blank (an empty string, in programming terms).

table-names
: What to call tables. The default is "Table".

title
: The title of the Markua document. The default is "Untitled".

urls
: The way that URLs should be displayed when used as links like `[Markua](http://markua.com)`. The choices are `none`, `inline` and `footnote`. The default is `footnote`, in which the URL is made as a footnote (positioned at the bottom of the page, chapter or book per the value of the `footnotes` attribute) which is a clickable link. Note that angle-bracket URLs like <http://markua.com> never create a footnote.